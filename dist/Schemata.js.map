{"version":3,"sources":["../src/Schemata.js"],"names":["runInjectors","SchemaInjectorConfig","stripResolversFromSchema","DefaultFieldMergeResolver","DefaultDirectiveMergeResolver","DefaultEnumMergeResolver","DefaultUnionMergeResolver","DefaultScalarMergeResolver","normalizeSource","debug_log","require","debug_trace","Schemata","String","constructor","typeDefs","resolvers","buildResolvers","flattenResolvers","GraphQLSchema","GRAPHIQL_FLAG","TYPEDEFS_KEY","MAP","WeakMap","set","wmkSchema","wmkResolvers","wmkPreboundResolvers","prevResolverMaps","get","EXE","Symbol","for","buildResolverForEachField","species","iterator","toString","bind","toStringTag","name","ast","parse","sdl","graphiql","value","schema","Class","buildSchema","error","type","typeName","typeDirectives","field","fieldName","fieldArgs","fieldDirectives","context","isRootType","resolve","astNode","delete","schemaResolvers","Object","keys","length","schemaDirectives","SCHEMA_DIRECTIVES","maps","executableSchema","types","forEachTypeField","t","tn","td","f","fn","fa","fd","c","definitions","fieldAST","fields","filter","o","i","a","fieldType","args","push","rootValue","schemaResolverFor","valid","_type","getType","_field","getFields","schemaFieldByName","validSchema","astTypeByName","validSDL","find","astFieldByName","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","conflictResolvers","DefaultConflictResolvers","source","Error","inline","lAST","rAST","_scalarFns","rType","lType","kind","endsWith","substring","combineTypeAndSubType","lScalar","lScalarConfig","rScalar","rScalarConfig","resolver","_scalarConfig","scalarMergeResolver","merged","from","gql","print","pareSDL","resolverMap","len","pareTypeAndSubType","index","indexOf","splice","values","result","merge","config","DefaultMergeOptions","mergedConfig","left","undefined","right","lResolvers","rResolvers","prevMaps","concat","ExtendedResolverMap","mergeResolvers","reduce","p","createMissingResolvers","clearSchema","injectMergedSchema","forEachField","ExtendedResolver","SchemaInjector","mergeSchema","flattenRootResolversOrFirstParam","extendWith","schemata","rootType","item","interim","r","defaultFieldResolver","hasAnExecutableSchema","e","clearResolvers","Util","inspect","custom","depth","options","valueOf","forEachOf","TYPES","suppliedSchema","forEachType","forEachInputObjectType","INPUT_TYPES","forEachUnion","UNIONS","forEachEnum","ENUMS","forEachInterface","INTERFACES","forEachScalar","SCALARS","forEachRootType","ROOT_TYPES","ALL","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","graphqlSync","runAsync","graphql","showError","schemaOpts","enhance","node","printSchema","HIDDEN","GraphQLObjectType","resolverArgs","Array","isArray","resolverInjectors","injector","extraConfig","baseConfig","__schema_injector__","info","_schema","leftType","leftField","rightType","rightField","leftDirective","rightDirective","leftValue","rightValue","leftUnion","rightUnion","leftScalar","leftConfig","rightScalar","rightConfig","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","subTypeResolverMap","Map","subTypeName","rSubType","lSubType","resultingSubType","wrap","body","trim"],"mappings":"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","file":"Schemata.js","sourceRoot":"src","sourcesContent":["// @flow\n\nconst debug_log = require('debug')('schemata:normal')\nconst debug_trace = require('debug')('schemata:trace')\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLScalarTypeConfig,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  ScalarTypeDefinitionNode,\n  Source,\n} from 'graphql'\n\nimport {\n  defaultFieldResolver,\n  GraphQLObjectType,\n  GraphQLSchema,\n  parse,\n  printSchema,\n  printType,\n  typeFromAST,\n} from 'graphql'\n\nimport type {\n  ConflictResolvers,\n  DirectiveMergeResolver,\n  EnumMergeResolver,\n  FieldMergeResolver,\n  MergeOptionsConfig,\n  ResolverArgs,\n  ResolverArgsTransformer,\n  ResolverMap,\n  ScalarMergeResolver,\n  SchemaSource,\n  UnionMergeResolver,\n} from './types'\n\nimport { ExtendedResolverMap } from './ExtendedResolverMap'\nimport { ExtendedResolver } from './ExtendedResolver'\nimport { inline } from 'ne-tag-fns'\nimport merge from 'deepmerge'\nimport Util from 'util'\n\nimport {\n  forEachOf,\n  forEachField,\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN,\n} from './forEachOf'\n\nimport type { ForEachOfResolver, ForEachFieldResolver } from './forEachOf'\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   */\n  constructor(\n    typeDefs: SchemaSource,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers =\n      resolvers ||\n      (typeDefs instanceof Schemata && typeDefs.resolvers) ||\n      (typeDefs instanceof GraphQLSchema &&\n        stripResolversFromSchema(typeDefs)) ||\n      null\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n    this[MAP].set(\n      wmkPreboundResolvers,\n      typeDefs instanceof Schemata ? typeDefs.prevResolverMaps : []\n    )\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n\n    // If buildResolvers is true, after the rest is already set and done, go\n    // ahead and build a new set of resolver functions for this instance\n    if (buildResolvers) {\n      if (buildResolvers === 'all') {\n        this[MAP].set(\n          wmkResolvers,\n          this.buildResolverForEachField(flattenResolvers)\n        )\n      }\n      else {\n        this[MAP].set(wmkResolvers, this.buildResolvers(flattenResolvers))\n      }\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species](): Function {\n    return Schemata\n  }\n\n  /**\n   * Redefine the iterator for Schemata instances so that they simply show the\n   * contents of the SDL/typeDefs.\n   *\n   * @type {Function}\n   */\n  get [Symbol.iterator](): Function {\n    return function*() {\n      yield this.toString()\n    }.bind(this)\n  }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag](): string {\n    return this.constructor.name\n  }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast(): ASTNode {\n    return this.constructor.parse(this.sdl, false)\n  }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with\n   * express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql(): boolean {\n    return this[GRAPHIQL_FLAG]\n  }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value: boolean): void {\n    this[GRAPHIQL_FLAG] = value\n  }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema(): GraphQLSchema {\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    // If we have a generated schema already and this instance has a\n    // resolvers object that is not falsey, check to see if the object\n    // has the executable schema flag set or not. If so, simply return\n    // the pre-existing object rather than create a new one.\n    if (this[MAP].get(wmkSchema)) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (resolvers) {\n        // check for the executable schema flag\n        if (schema && schema[EXE]) {\n          return schema\n        }\n      }\n      else if (schema) {\n        return schema\n      }\n    }\n\n    // Attempt to generate a schema using the SDL for this instance. Throw\n    // an error if the SDL is insufficient to generate a GraphQLSchema object\n    try {\n      debug_log('[get .schema] creating schema from SDL')\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n    }\n    catch (error) {\n      debug_log('[get .schema] failed to create schema')\n      debug_trace('[get .schema] ERROR!', error)\n      return null\n    }\n\n    // Only iterate over the fields if there are resolvers set\n    if (resolvers) {\n      forEachField(\n        schema,\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (!resolvers) {\n            return\n          }\n\n          if (isRootType(type) && resolvers[fieldName]) {\n            field.resolve = resolvers[fieldName]\n            field.astNode.resolve = resolvers[fieldName]\n          }\n\n          if (resolvers[typeName] && resolvers[typeName][fieldName]) {\n            field.resolve = resolvers[typeName][fieldName]\n            field.astNode.resolve = resolvers[typeName][fieldName]\n          }\n        }\n      )\n\n      schema[EXE] = true\n    }\n\n    // Set the generated schema in the weak map using the weak map key\n    this[MAP].set(wmkSchema, schema)\n\n    return schema\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store. If the value\n   * supplied is not truthy (i.e. null, undefined, or even false) then this\n   * method deletes any stored schema in the internal map. Otherwise, the\n   * supplied value is set on the map and subsequent get calls to `.schema`\n   * will return the value supplied.\n   *\n   * If there are bound resolvers on the supplied schema, a symbol denoting\n   * that the schema is an executable schema will be set to prevent it from\n   * being overwritten on subsequent get operations. The bound resolvers will\n   * be merged with the Schemata's resolvers object.\n   *\n   * If resolvers are subsequently set on the `Schemata` instance and the\n   * supplied schema does not have resolvers bound to it, subsequent get\n   * requests for the internal `.schema` may auto-generate a new one with\n   * bound resolvers. You have been warned. =)\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema: ?GraphQLSchema): void {\n    debug_log('[set .schema]: ', schema ? 'truthy' : 'falsey')\n    debug_trace('[set .schema] ', schema)\n\n    if (!schema) {\n      this[MAP].delete(wmkSchema)\n    }\n    else {\n      let schemaResolvers = stripResolversFromSchema(schema)\n\n      if (Object.keys(schemaResolvers).length) {\n        schema[EXE] = true\n\n        merge((this.resolvers = this.resolvers || {}), schemaResolvers)\n      }\n\n      this[MAP].set(wmkSchema, schema)\n    }\n  }\n\n  /**\n   * Retrieves the `schemaDirectives` value, which defaults to true. This\n   * value can make setting up an endpoint from a Schemata instance easier\n   * with apollo-server or graphql-yoga or compatible variants. See\n   * https://www.apollographql.com/docs/graphql-tools/schema-directives.html\n   * if you are using this value with apollo-server.\n   *\n   * @type {Object}\n   */\n  get schemaDirectives(): boolean {\n    return this[SCHEMA_DIRECTIVES]\n  }\n\n  /**\n   * Retrieves the `schemaDirectives` value, which defaults to true. This\n   * value can make setting up an endpoint from a Schemata instance easier\n   * with apollo-server or graphql-yoga or compatible variants. See\n   * https://www.apollographql.com/docs/graphql-tools/schema-directives.html\n   * if you are using this value with apollo-server.\n   *\n   * @type {Object}\n   */\n  set schemaDirectives(value: {string: Function}) {\n    this[SCHEMA_DIRECTIVES] = value\n  }\n\n  /**\n   * When a Schemata instance is merged with another GraphQLSchema, its\n   * resolvers get stored before they are wrapped in a function that updates\n   * the schema object it receives. This allows them to be wrapped safely at\n   * a later date should this instance be merged with another.\n   *\n   * @return {Array<ExtendedResolverMap>} an array of `ExtendedResolverMap`\n   * object instances\n   */\n  get prevResolverMaps(): Array<ExtendedResolverMap> {\n    return this[MAP].get(wmkPreboundResolvers)\n  }\n\n  /**\n   * Sets the pre-bound resolver map objects as an array of\n   * `ExtendedResolverMap` object instances on this instance of Schemata\n   *\n   * @param {Array<ExtendedResolverMap>} maps an array of `ExtendedResolverMap`\n   * object instances\n   */\n  set prevResolverMaps(maps: Array<ExtendedResolverMap>): void {\n    this[MAP].set(wmkPreboundResolvers, maps)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If there are no resolvers, this is essentially\n   * the same as asking for a schema instance using `.schema`. If the SDL\n   * this instance is built around is insufficient to generate a GraphQLSchema\n   * instance, then an error will be thrown.\n   *\n   * @deprecated use `.schema` instead; this simply proxies to that\n   * @return {GraphQLSchema} an instance of GraphQLSchema with pre-bound\n   * resolvers\n   */\n  get executableSchema(): GraphQLSchema {\n    return this.schema\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @return {string} the string this class instance represents\n   */\n  get sdl(): string {\n    return this[TYPEDEFS_KEY]\n  }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @return {string} a string of SDL/IDL for use with graphql\n   */\n  get typeDefs(): string {\n    return this.sdl\n  }\n\n  /**\n   * Walks the types defined in the sdl for this instance of Schemata and\n   * returns an object mapping for those definitions. Given a schema such as\n   * ```\n   * type A {\n   *   a: String\n   *   b: [String]\n   *   c: [String]!\n   * }\n   * type Query {\n   *   As(name: String): [A]\n   * }\n   * ```\n   * a JavaScript object with properties such as the following will be\n   * returned\n   * ```\n   * {\n   *   Query: {\n   *     As: { type: '[A]', args: [{ name: 'String' }] }\n   *   },\n   *   A: {\n   *     a: { type: 'String', args: [] },\n   *     b: { type: '[String]', args: [] },\n   *     c: { type: '[String]!', args: [] }\n   *   }\n   * }\n   * ```\n   */\n  get types(): Object {\n    let types = {}\n\n    this.forEachTypeField((t,tn,td,f,fn,fa,fd,schema,c) => {\n      let ast = parse(printType(t)).definitions[0]\n      let fieldAST = ast.fields.filter((o,i,a) => o.name.value == fn)\n      let fieldType = fieldAST.length && typeFromAST(schema, fieldAST[0].type)\n      let args = []\n\n      if (fa && fa.length) {\n        for (let {name, type} of fa) {\n          args.push({ [name]: type.toString() })\n        }\n      }\n\n      (types[tn] = types[tn] || {})[fn] = {\n        type: fieldType.toString(),\n        args: args\n      }\n    })\n\n    return types\n  }\n\n  /**\n   * An internal call to buildResolvers(true), thereby requesting a flattened\n   * resolver map with Query, Mutation and Subscription fields exposed as root\n   * objects the way the Facebook reference implementation expects\n   *\n   * @return {Object} an object of functions or an empty object otherwise\n   */\n  get rootValue(): ResolverMap {\n    return this.buildResolvers(true)\n  }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {Object} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers(): ResolverMap {\n    return this[MAP].get(wmkResolvers)\n  }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type: string, field: string): ?Function {\n    if (!this.resolvers || !Object.keys(this.resolvers).length || !this.valid) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n    let resolve = (_field && _field.resolve) || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSchema || !this.schema) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type: string): ASTNode {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type: string, field: string): FieldNode {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field =\n      (_type && _type.fields.find(f => f.name.value === field)) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers(): boolean {\n    let asts = (this.validSDL && this.ast.definitions) || null\n\n    if (!asts || !this.resolvers) {\n      return false\n    }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type || !type.fields) {\n        continue\n      }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage: SchemaSource,\n    conflictResolvers: ?ConflictResolvers = DefaultConflictResolvers\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n    let _scalarFns = {}\n\n    // Ensure we have default behavior with any custom behavior assigned\n    // atop the default ones should only a partial custom be supplied.\n    conflictResolvers = merge(DefaultConflictResolvers, conflictResolvers)\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind &&\n        rType.kind.endsWith &&\n        rType.kind.endsWith('Extension')\n      ) {\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      default:\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n        break\n\n      case 'EnumTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('values', lType, rType, conflictResolvers)\n        break\n\n      case 'UnionTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('types', lType, rType, conflictResolvers)\n        break\n\n      case 'ScalarTypeDefinitionNode':\n        let lScalar, lScalarConfig, rScalar, rScalarConfig, resolver\n\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n\n        if (this.schema) {\n          lScalar = this.schema.getType(lType.name.value)\n          lScalarConfig = (lScalar && lScalar._scalarConfig) || null\n        }\n\n        if (source.schema) {\n          rScalar = source.schema.getType(rType.name.value)\n          rScalarConfig = (rScalar && rScalar._scalarConfig) || null\n        }\n\n        resolver = (conflictResolvers.scalarMergeResolver ||\n            DefaultConflictResolvers.scalarMergeResolver)(\n          lType,\n          lScalarConfig,\n          rType,\n          rScalarConfig\n        )\n\n        if (resolver) {\n          _scalarFns[lType.name.value] = _scalarFns[lType.name.value] || {}\n          _scalarFns[lType.name.value] = resolver\n        }\n\n        break\n      }\n    }\n\n    let merged = Schemata.from(this.constructor.gql.print(lAST))\n\n    if (Object.keys(_scalarFns).length) {\n      for (let typeName of Object.keys(_scalarFns)) {\n        merged.schema.getType(typeName)._scalarConfig = _scalarConfig[typeName]\n      }\n    }\n\n    return merged\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ResolverMap} resolverMap an object containing resolver functions,\n   * from either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage: SchemaSource,\n    resolverMap: ?ResolverMap = null\n  ): Schemata {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = merge({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (\n        rType.kind &&\n        rType.kind.endsWith &&\n        rType.kind.endsWith('Extension')\n      ) {\n        let len = 'Extension'.length\n\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      default:\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('fields', lType, rType, resolvers)\n\n        if (!lType.fields.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'EnumTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('values', lType, rType, resolvers)\n\n        if (!lType.values.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'UnionTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('types', lType, rType, resolvers)\n\n        if (!lType.types.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'ScalarTypeDefinitionNode':\n        let index = lAST.definitions.indexOf(lType)\n\n        if (index !== -1) {\n          lAST.definitions.splice(index, 1)\n        }\n        break\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.schema\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  merge(\n    schema: SchemaSource,\n    config?: MergeOptionsConfig = DefaultMergeOptions\n  ): Schemata {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    // Step0: Ensure we have all the defaults for config and schema\n    schema = normalizeSource(schema, true)\n\n    if (config !== DefaultMergeOptions) {\n      let mergedConfig = merge({}, DefaultMergeOptions)\n      config = merge(mergedConfig, config)\n    }\n\n    // Step1: Merge SDL; quit at this point if there are no resolvers\n    let left = Schemata.from(this, undefined, true)\n    let right = Schemata.from(schema, undefined, true)\n    let merged = left.mergeSDL(right, config.conflictResolvers)\n\n    // If neither schemata instance has a resolver, there is no reason\n    // to continue. Return the merged schemas and call it a day.\n    if (\n      (!left.resolvers || !Object.keys(left.resolvers).length) &&\n      (!right.resolvers || !Object.keys(right.resolvers).length)\n    ) {\n      return merged\n    }\n\n    // Step2: Backup resolvers from left, right, or both\n    let lResolvers = left.resolvers\n    let rResolvers = right.resolvers\n    let prevMaps = (left.prevResolverMaps || []).concat(\n      right.prevResolverMaps || [],\n      ExtendedResolverMap.from(left),\n      ExtendedResolverMap.from(right)\n    )\n    merged.prevResolverMaps = prevMaps\n\n    // Step3: Merge resolvers\n    let mergeResolvers = {}\n\n    if (prevMaps && prevMaps.length) {\n      mergeResolvers = prevMaps.reduce((p, c, i, a) => {\n        return merge(p, c.resolvers || {})\n      }, {})\n    }\n    else {\n      merge(mergeResolvers, left.resolvers)\n      merge(mergeResolvers, right.resolvers)\n    }\n    merged.resolvers = mergeResolvers\n\n    // Step 4: Trigger a new schema creation\n    if (config.createMissingResolvers) {\n      merged.resolvers = merged.buildResolverForEachField()\n    }\n    merged.clearSchema()\n    merged.schema\n\n    // Step5: Wrap resolvers\n    if (config.injectMergedSchema) {\n      merged.forEachField(\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (field.resolve) {\n            field.resolve = ExtendedResolver.SchemaInjector(\n              field.resolve,\n              merged.schema\n            )\n\n            if (!merged.resolvers[typeName]) {\n              merged.resolvers[typeName] = {}\n            }\n\n            merged.resolvers[typeName][fieldName] = field.resolve\n          }\n        }\n      )\n\n      // Do this once more to ensure we are using the modified resolvers\n      merged.clearSchema()\n      merged.schema\n    }\n\n    // Step6: Return final merged product\n    return merged\n  }\n\n  /**\n   * Shortcut for the merge() function; mergeSDL still exists as an entity of\n   * itself, but merge() will invoke that function as needed to do its job and\n   * if there aren't any resolvers to consider, the functions act identically.\n   *\n   * @see merge\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema to merge\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema: GraphQLSchema | Schemata,\n    config?: MergeOptionsConfig = DefaultMergeOptions\n  ): Schemata {\n    return this.merge(schema, config)\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an Object, it will be merged in normally\n   * with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = merge(\n      {},\n      stripResolversFromSchema(schemata.schema) || schemata.resolvers || {}\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            try {\n              debug_log('[buildResolvers()] finding field in schema')\n              if (schemata.schemaFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n            catch (error) {\n              debug_log(inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\`\n              `)\n              debug_trace(\n                inline`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\` due to\n              `,\n                error\n              )\n\n              if (schemata.astFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      resolvers = merge(resolvers || {}, flattenRootResolversOrFirstParam || {})\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      for (let item of extendWith) {\n        resolvers = merge(resolvers || {}, item || {})\n      }\n    }\n\n    return resolvers\n  }\n\n  /**\n   * From time to time it makes more sense to wrap every possible resolver\n   * mapping in given schema. Getting a handle to each fields resolver and\n   * or substituting missing ones with GraphQL's defaultFieldResolver can\n   * be a tiresome affair. This method walks the schema for you and returns\n   * any previously defined resolvers alongside defaultFieldResolvers for\n   * each possible field of every type in the schema.\n   *\n   * If a schema cannot be generated from the SDL represented by the instance\n   * of Schemata, then an error is thrown.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an ResolverMap, it will be merged in\n   * normally with merge.\n   * @param {Array<ResolverMap>} ...extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolverForEachField(\n    flattenRootResolversOrFirstParam: boolean | ResolverMap,\n    ...extendWith: Array<ResolverMap>\n  ): ResolverMap {\n    if (!this.schema) {\n      throw new Error(inline`\n        buildResolverForEachField() cannot be called unless there is enough\n        valid SDL in the instance to construct a schema. Please check your\n        code!\n      `)\n    }\n\n    let interim = Schemata.from(this.sdl, this.resolvers)\n    let r = {}\n\n    interim.forEachField(\n      (\n        type,\n        typeName,\n        typeDirectives,\n        field,\n        fieldName,\n        fieldArgs,\n        fieldDirectives,\n        schema,\n        context\n      ) => {\n        // Ensure the path to the type in question exists before continuing\n        // onward\n        (r[typeName] = r[typeName] || {})[fieldName] =\n          (r[typeName][fieldName] || {})\n\n        r[typeName][fieldName] = field.resolve || defaultFieldResolver\n      }\n    )\n\n    interim.resolvers = r\n\n    return interim.buildResolvers(\n      flattenRootResolversOrFirstParam,\n      ...extendWith\n    )\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @return {boolean} true if there is at least one resolver on at least one\n   * field of a type in this Schemata instance's schema.\n   */\n  get hasAnExecutableSchema(): boolean {\n    return Object.keys(this.buildResolvers()).length > 0\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @return {boolean} true if the string can be parsed; false otherwise\n   */\n  get validSDL(): boolean {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      debug_log('[get .validSDL] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSDL] false')\n      debug_trace('[get .validSDL] ', e)\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @return {boolean} true if the string can be parsed into a schema; false\n   * otherwise\n   */\n  get validSchema(): boolean {\n    try {\n      this.schema\n      debug_log('[get .validSchema] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSchema] false')\n      debug_trace('[get .validSchema] ', e)\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @return {boolean} true if it is valid for both `parse()` as well as the\n   * `buildSchema()` function\n   */\n  get valid(): boolean {\n    return this.validSDL && this.validSchema\n  }\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * this string instance.\n   */\n  set resolvers(resolvers: ?ResolverMap): void {\n    this[MAP].set(wmkResolvers, resolvers)\n    this.clearSchema()\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers(): void {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema(): void {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} the SDL/IDL string this class was created on\n   */\n  [Util.inspect.custom](depth, options): string {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  toString(): string {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} [description]\n   */\n  valueOf(): string {\n    return this.sdl\n  }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: GraphQLSchema,\n   *   context: mixed,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {Number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(\n    fn: ForEachOfResolver,\n    context: mixed,\n    types: number = TYPES,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated over and returned.\n   */\n  forEachType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated\n   * over and returned.\n   */\n  forEachInputObjectType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(\n    fn: ForEachOfResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema\n  ): GraphQLSchema {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: mixed,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: mixed,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: GraphQLSchema,\n   *   context: mixed\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * @param {Function} fn a function with a signature defined above\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    types: number = ALL,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {mixed} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(\n    fn: ForEachFieldResolver,\n    context: mixed,\n    suppliedSchema: ?GraphQLSchema = null\n  ): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} rootValue provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any, any>\n  ): ExecutionResult {\n    return this.constructor.gql.graphqlSync(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver\n    )\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {mixed} contextValue a bit of shared context to pass to resolvers\n   * @param {Object} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap|null} The value provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<any, any>} fieldResolver A resolver function\n   * to use when one is not provided by the schema. If not provided, the\n   * default field resolver is used (which looks for a value or method on the\n   * source value with the field's name).\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query: string | Source,\n    contextValue?: mixed,\n    variableValues?: ?ObjMap<mixed>,\n    rootValue?: mixed,\n    operationName?: ?string,\n    fieldResolver?: ?GraphQLFieldResolver<any, any>\n  ): Promise<ExecutionResult> {\n    return this.constructor.gql.graphql(\n      this.schema,\n      query,\n      this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver\n    )\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} showError true if the error should be thrown, false if\n   * the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} schemaOpts for advanced users,\n   * passing through additional buildSchema() options can be done here\n   * @return {GraphQLSchema|null} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(\n    sdl: SchemaSource,\n    showError: boolean = false,\n    schemaOpts: BuildSchemaOptions & ParseOptions = undefined\n  ): ?GraphQLSchema {\n    try {\n      debug_log('[static buildSchema()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static buildSchema()] building schema')\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      debug_log('[static buildSchema()] failed to build!')\n      debug_trace('[static buildSchema()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @param {boolean} enhance a generator keyed with `Symbol.iterator` is set\n   * on the resulting astNode object allowing the resulting `.ast` value to\n   * be iterable. The code iterates over each definition of the resulting\n   * DocumentNode. This behavior defaults to true and should not have any ill\n   * effects on code expecting vanilla ASTNode objects\n   * @return {ASTNode|null} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(\n    sdl: SchemaSource,\n    showError: boolean = false,\n    enhance: boolean = true\n  ): ?ASTNode {\n    try {\n      debug_log('[static parse()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static parse()] parsing')\n      let node = this.gql.parse(source)\n\n      if (enhance) {\n        debug_log('[static parse()] enhancing')\n        node[Symbol.iterator] = function*() {\n          for (let node of this.definitions) {\n            yield node\n          }\n        }\n      }\n\n      return node\n    }\n    catch (e) {\n      debug_log('[static parse()] failed to parse')\n      debug_trace('[static parse()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when printing an ASTNode\n   * to string form using `require('graphql').print()`. If `showError` is true\n   * any thrown errors will be rethrown, otherwise null is returned instead.\n   *\n   * Should all go as planned, an instance of Schemata wrapped with the printed\n   * SDL will be returned.\n   *\n   * @since 1.7\n   *\n   * @param {ASTNode|GraphQLSchema} ast an ASTNode, usually a\n   * DocumentNode generated with some version of `require('graphql').parse()`.\n   * If an instance of GraphQLSchema is supplied, `printSchema()` is used\n   * instead of `print()`\n   * @param {boolean} showError if true, any caught errors will be thrown once\n   * again\n   * @return {Schemata|null} null if an error occurs (and showError is false)\n   * or an instance of Schemata wrapping the resulting SDL string from the\n   * print operation\n   */\n  static print(\n    ast: ASTNode | GraphQLSchema,\n    showError: boolean = false\n  ): ?Schemata {\n    try {\n      let source\n\n      if (ast instanceof GraphQLSchema) {\n        debug_log('[static print()] printing schema')\n        source = this.gql.printSchema(ast)\n      }\n      else {\n        debug_log('[static print()] printing ASTNode')\n        source = this.gql.print(ast)\n      }\n\n      debug_log('[static print()] creating new Schemata from print')\n      return Schemata.from(source)\n    }\n    catch (e) {\n      debug_log('[static print()] failed to print')\n      debug_trace('[static print()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {mixed} the results of `require('graphql')`\n   */\n  static get gql(): mixed {\n    return require('graphql')\n  }\n\n  /**\n   * Shorthand way of invoking `new Schemata()`\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs: SchemaSource,\n    resolvers: ?ResolverMap = null,\n    buildResolvers: boolean | string = false,\n    flattenResolvers: boolean = false\n  ): Schemata {\n    return new this(typeDefs, resolvers, buildResolvers, flattenResolvers)\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL(): number {\n    return ALL\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES(): number {\n    return TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES(): number {\n    return INTERFACES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS(): number {\n    return ENUMS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS(): number {\n    return UNIONS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS(): number {\n    return SCALARS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES(): number {\n    return ROOT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES(): number {\n    return INPUT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN(): number {\n    return HIDDEN\n  }\n}\n\n/**\n * Given an type, determine if the type is a root type; i.e. one of Query,\n * Mutation or Subscription as defined in the `graphql` library.\n *\n * @param  {mixed} t a GraphQL AST or object type denoting a schema type\n * @return {Boolean} true if the type supplied is a root type; false otherwise\n */\nexport const isRootType = t => {\n  if (t === undefined || t === null || !t) {\n    return false\n  }\n\n  let name = typeof t.name === 'string' ? t.name : t.name.value\n\n  return (\n    t instanceof GraphQLObjectType &&\n    (t.name === 'Query' || t.name === 'Mutation' || t.name === 'Subscription')\n  )\n}\n\n/**\n * Loops over the `resolverInjectors` in the supplied config object and\n * lets each supplied function have a pass to inspect or modify the parameters\n * that will be used to bind future resolver functions.\n *\n * @param {MergeOptionsConfig} config a config object with an array of\n * `ResolverArgsTransformer` functions\n * @param {ResolverArgs} args an object with `source`, `args`, `context`\n * and `info`\n * @return {ResolverArgs} a resulting object with `source`, `args`,\n * `context` and `info`\n */\nexport function runInjectors(\n  config: MergeOptionsConfig,\n  resolverArgs: ResolverArgs\n): ResolverArgs {\n  let args: ResolverArgs\n\n  if (!Array.isArray(config.resolverInjectors)) {\n    config.resolverInjectors = [config.resolverInjectors]\n  }\n\n  for (let injector of config.resolverInjectors) {\n    args = injector(resolverArgs)\n  }\n\n  return args\n}\n\n/**\n * The merge options config takes the arguments passed into a given `resolve()`\n * function, allowing the implementor to modify the values before passing them\n * back out.\n *\n * This function takes a schema to inject into the info object, or fourth\n * parameter, passed to any resolver. Any `extraConfig` object added in will\n * have its resolverInjectors added to the list to be processed.\n *\n * @param {GraphQLSchema} schema the GraphQLSchema object being inserted\n * @param {MergeOptionsConfig} extraConfig an optional extraConfig option to\n * merge with the resulting output\n * @return {MergeOptionsConfig} a MergeOptionsConfig object that contains at\n * least a single `ResolverArgsTransformer` which injects the supplied `schema`\n * into the `info` object.\n */\nexport function SchemaInjectorConfig(\n  schema: GraphQLSchema,\n  extraConfig?: MergeOptionsConfig\n): MergeOptionsConfig {\n  let baseConfig = {\n    resolverInjectors: [\n      function __schema_injector__({ source, args, context, info }) {\n        info.schema = schema || info.schema\n        return { source, args, context, info }\n      },\n    ],\n  }\n\n  if (extraConfig) {\n    if (extraConfig.resolverInjectors) {\n      if (!Array.isArray(extraConfig.resolverInjectors)) {\n        baseConfig.resolverInjectors.push(extraConfig.resolverInjectors)\n      }\n      else {\n        baseConfig.resolverInjectors = baseConfig.resolverInjectors.concat(\n          extraConfig.resolverInjectors\n        )\n      }\n    }\n  }\n\n  return baseConfig\n}\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {ResolverMap} an object containing a mapping of typeName.fieldName\n * that links to the resolve() function it is associated within the supplied\n * schema\n */\nexport function stripResolversFromSchema(schema: GraphQLSchema): ?ResolverMap {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(\n    schema,\n    (\n      type,\n      typeName,\n      typeDirectives,\n      field,\n      fieldName,\n      fieldArgs,\n      fieldDirectives,\n      _schema,\n      context\n    ) => {\n      if (field.resolve) {\n        resolvers[typeName] = resolvers[typeName] || {}\n        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n        resolvers[typeName][fieldName] = field.resolve\n      }\n    }\n  )\n\n  return resolvers\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol('internal-typedefs-key')\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('internal-graphiql-key')\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const SCHEMA_DIRECTIVES = Symbol.for('internal-directives-key')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol('internal-weak-map-key')\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol('executable-schema')\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol('GraphQL Resolvers storage key'))\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol('GraphQLSchema storage key'))\n\n/**\n * This is a `Symbol` key to a `WeakSet` of `ExtendedResolverMap` instances,\n * each of which have at least three properties:\n *\n *  - schema\n *  - sdl\n *  - resolvers\n *\n * One of these are created and added to the set whenever a mergeSchema is\n * performed. On each subsequent mergeSDL/Schema a new instance is added such\n * that new versions exist to be wrapped anew\n *\n * @type {[type]}\n */\nconst wmkPreboundResolvers = Object(Symbol('Resolvers pre-merge-wrapped'))\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n): FieldNode {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n): DirectiveNode {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n): EnumValueNode {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n): NamedTypeNode {\n  return rightUnion\n}\n\n/**\n * The default scalar merge resolver returns the right config when there is\n * one, otherwise the left one or null will be the default result. This is\n * slightly different behavior since resolvers for scalars are not always\n * available.\n *\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport function DefaultScalarMergeResolver(\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n): GraphQLScalarTypeConfig {\n  return rightConfig ? rightConfig : leftConfig || null\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers: ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver,\n\n  /** A handler for resolving scalar configs in custom scalars */\n  scalarMergeResolver: DefaultScalarMergeResolver,\n}\n\n/**\n * A `MergeOptionsConfig` object with an empty array of\n * `ResolverArgsTransformer` instances\n *\n * @type {MergeOptionsConfig}\n */\nexport const DefaultMergeOptions: MergeOptionsConfig = {\n  conflictResolvers: DefaultConflictResolvers,\n  resolverInjectors: [],\n  injectMergedSchema: true,\n  createMissingResolvers: false,\n}\n\nconst subTypeResolverMap: Map<string, Function> = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\nsubTypeResolverMap.set('scalars', 'scalarMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  conflictResolvers: ConflictResolvers = DefaultConflictResolvers\n): void {\n  if (rType[subTypeName]) {\n    for (let rSubType of rType[subTypeName]) {\n      let lSubType = lType[subTypeName].find(\n        f => f.name.value == rSubType.name.value\n      )\n\n      if (!lSubType) {\n        lType[subTypeName].push(rSubType)\n        continue\n      }\n\n      let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n      let resultingSubType = conflictResolvers[resolver](\n        lType,\n        lSubType,\n        rType,\n        rSubType\n      )\n      let index = lType.fields.indexOf(lSubType)\n\n      lType[subTypeName].splice(index, 1, resultingSubType)\n    }\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(\n  subTypeName: string,\n  lType: ASTNode,\n  rType: ASTNode,\n  resolvers: ResolverMap = {}\n): void {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (\n      resolvers[lType.name.value] &&\n      resolvers[lType.name.value][lSubType.name.value]\n    ) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n * as an SDL string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(\n  typeDefs: SchemaSource,\n  wrap: boolean = false\n): string | Schemata {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  if (typeDefs instanceof Schemata && typeDefs.valid && wrap) {\n    return typeDefs\n  }\n\n  let source = (\n    typeDefs.body ||\n    typeDefs.sdl ||\n    (typeof typeDefs === 'string' && typeDefs) ||\n    (typeof typeDefs === 'object' && Schemata.print(typeDefs)) ||\n    (typeDefs instanceof GraphQLSchema\n      ? printSchema(typeDefs)\n      : typeDefs.toString())\n  ).toString().trim()\n\n  return wrap ? Schemata.from(source) : source\n}\n\nexport default Schemata\n"]}