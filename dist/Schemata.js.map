{"version":3,"file":"Schemata.js","names":["_debug","_interopRequireDefault","require","_promises","_path","_graphql","_GraphQLExtension","_utils","_resolverwork","_ExtendedResolverMap","_ExtendedResolver","_neTagFns","_walkResolverMap","_deepmerge","_util","_forEachOf","_dynamicImport","e","__esModule","default","debug_log","debug","debug_trace","Schemata","String","constructor","typeDefs","resolvers","buildResolvers","flattenResolvers","normalizeSource","GraphQLSchema","stripResolversFromSchema","GRAPHIQL_FLAG","TYPEDEFS_KEY","MAP","WeakMap","set","wmkSchema","wmkResolvers","wmkPreboundResolvers","prevResolverMaps","get","EXE","Symbol","for","buildResolverForEachField","species","iterator","toString","bind","toStringTag","name","ast","parse","sdl","graphiql","value","schema","generateSchema","delete","schemaResolvers","Object","keys","length","merge","schemaDirectives","SCHEMA_DIRECTIVES","maps","executableSchema","flattenSDL","printSchema","flatSDL","types","forEachTypeField","t","tn","td","f","fn","fa","fd","c","printType","definitions","fieldAST","fields","filter","o","i","a","fieldType","typeFromAST","type","args","push","rootValue","resolverInfo","extractResolverInfo","schemaResolverFor","field","valid","_type","getType","_field","getFields","resolve","schemaFieldByName","validSchema","astTypeByName","validSDL","find","astFieldByName","hasFlattenedResolvers","asts","query","mutation","subscription","mergeSDL","schemaLanguage","conflictResolvers","DefaultConflictResolvers","source","Error","inline","lAST","rAST","_scalarFns","rType","lType","kind","endsWith","substring","combineTypeAndSubType","lScalar","lScalarConfig","rScalar","rScalarConfig","resolver","_scalarConfig","scalarMergeResolver","merged","from","gql","print","typeName","pareSDL","resolverMap","len","pareTypeAndSubType","values","index","indexOf","splice","result","config","DefaultMergeOptions","mergedConfig","left","undefined","right","prevMaps","concat","ExtendedResolverMap","mergeResolvers","reduce","p","createMissingResolvers","clearSchema","injectMergedSchema","forEachField","typeDirectives","fieldName","fieldArgs","fieldDirectives","context","ExtendedResolver","SchemaInjector","mergeSchema","flattenRootResolversOrFirstParam","extendWith","schemata","rootType","error","dedent","item","interim","r","defaultFieldResolver","hasAnExecutableSchema","clearResolvers","Util","inspect","custom","valueOf","forEachOf","suppliedSchema","forEachType","TYPES","forEachInputObjectType","INPUT_TYPES","forEachUnion","UNIONS","forEachEnum","ENUMS","forEachInterface","INTERFACES","forEachScalar","SCALARS","forEachRootType","ROOT_TYPES","ALL","forEachInterfaceField","forEachInputObjectField","run","contextValue","variableValues","operationName","fieldResolver","typeResolver","graphqlSync","runAsync","graphql","buildSchema","showError","schemaOpts","enhance","node","fromContentsOf","path","resolved","pathResolve","contents","readFile","buildFromDir","options","conflictResolver","_","newResolver","gqExts","jsExts","resolversRoots","projectRoot","parseAndRemoveExtension","pathParse","base","ext","isDirectory","asyncTryCatch","stat","rePathDir","dir","rePath","uniqueStems","Set","readdir","recursive","asyncPrevious","current","previous","fullPath","pathJoin","isDir","console","log","pathFormat","skip","n","guessProjectRoot","resolverRoots","Array","isArray","paths","unknown","hasValues","resolverRoot","stem","stemParsed","rootRelative","includes","pathRelative","results","resolvedPaths","importResolvedGraphQL","HIDDEN","#generateSchema","Class","extendSchema","isRootType","astNode","forEach","applyTo","exports","GraphQLObjectType","runInjectors","resolverArgs","resolverInjectors","injector","SchemaInjectorConfig","extraConfig","baseConfig","__schema_injector__","info","_schema","DefaultFieldMergeResolver","leftType","leftField","rightType","rightField","DefaultDirectiveMergeResolver","leftDirective","rightDirective","DefaultEnumMergeResolver","leftValue","rightValue","DefaultUnionMergeResolver","leftUnion","rightUnion","DefaultScalarMergeResolver","leftScalar","leftConfig","rightScalar","rightConfig","fieldMergeResolver","directiveMergeResolver","enumValueMergeResolver","typeValueMergeResolver","subTypeResolverMap","Map","subTypeName","rSubType","lSubType","resultingSubType","wrap","body","trim","_default"],"sources":["../src/Schemata.js"],"sourcesContent":["// @ts-check\n\nimport { default as debug } from 'debug'\n\nconst debug_log = debug('Schemata:log')\nconst debug_trace = debug('Schemata:trace')\n\nimport {\n  readdir,\n  readFile,\n  stat\n} from 'fs/promises'\n\nimport {\n  format as pathFormat,\n  resolve as pathResolve,\n  join as pathJoin,\n  parse as pathParse,\n  relative as pathRelative\n} from 'path'\n\nimport type {\n  ASTNode,\n  BuildSchemaOptions,\n  DirectiveNode,\n  EnumValueNode,\n  ExecutionResult,\n  FieldNode,\n  GraphQLFieldResolver,\n  GraphQLScalarTypeConfig,\n  NamedTypeNode,\n  ObjMap,\n  ParseOptions,\n  ScalarTypeDefinitionNode,\n  Source,\n} from 'graphql'\n\nimport {\n  defaultFieldResolver,\n  extendSchema,\n  GraphQLObjectType,\n  GraphQLSchema,\n  parse,\n  printSchema,\n  printType,\n  typeFromAST,\n} from 'graphql'\n\nimport {\n  AllSchemataExtensions,\n  importGraphQL,\n  importResolvedGraphQL,\n  resolvedPaths\n} from './GraphQLExtension'\n\nimport type {\n  ConflictResolvers,\n  DirectiveMergeResolver,\n  EnumMergeResolver,\n  FieldMergeResolver,\n  MergeOptionsConfig,\n  ResolverArgs,\n  ResolverArgsTransformer,\n  ResolverInfo,\n  ResolverMap,\n  ScalarMergeResolver,\n  SchemaSource,\n  UnionMergeResolver,\n} from './types'\n\nimport { asyncTryCatch } from './utils'\nimport { extractResolverInfo } from './utils/resolverwork'\nimport { ExtendedResolverMap } from './ExtendedResolverMap'\nimport { ExtendedResolver } from './ExtendedResolver'\nimport { inline, dedent } from 'ne-tag-fns'\nimport { mergeResolvers, ResolverProperty } from './walkResolverMap'\nimport merge from 'deepmerge'\nimport Util from 'util'\n\nimport {\n  forEachOf,\n  forEachField,\n  ALL,\n  TYPES,\n  INTERFACES,\n  ENUMS,\n  UNIONS,\n  SCALARS,\n  ROOT_TYPES,\n  HIDDEN,\n} from './forEachOf'\nimport { fileExists, findNearestPackageJson, guessProjectRoot } from './dynamicImport'\n\n/**\n * @typedef {import('./forEachOf').ForEachOfResolver} ForEachOfResolver\n * @typedef {import('./forEachOf').ForEachFieldResolver} ForEachFieldResolver\n * @typedef {import('./forEachOf').BitmaskedType} BitmaskedType\n */\n\n/**\n * A small `String` extension that makes working with SDL/IDL text far easier\n * in both your own libraries as well as in a nodeJS REPL. Built-in to what\n * appears to be a normal String for all intents and purposes, are the ability\n * to transform the string into a set of AST nodes, a built schema or back to\n * the SDL string.\n *\n * @class  Schemata\n */\nexport class Schemata extends String {\n  /**\n   * Creates a new `String`, presumably of SDL or IDL. The getter `.valid`\n   * will provide some indication as to whether or not the code is valid.\n   *\n   * @constructor\n   * @memberOf Schemata\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} resolvers an object containing field resolvers for\n   * for the schema represented with this string. [Optional]\n   * @param {boolean} buildResolvers if this flag is set to true, build a set\n   * of resolvers after the rest of the instance is initialized and set the\n   * results on the `.resolvers` property of the newly created instance. If\n   * buildResolvers is the string \"all\", then a resolver for each field not\n   * defined will be returned with a `defaultFieldResolver` as its value\n   * @param {boolean} flattenResolvers if true, and if `buildResolvers` is true,\n   * then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   */\n  constructor(\n    typeDefs,\n    resolvers = null,\n    buildResolvers = false,\n    flattenResolvers = false,\n  ) {\n    super(normalizeSource(typeDefs))\n\n    resolvers =\n      resolvers ||\n      (typeDefs instanceof Schemata && typeDefs.resolvers) ||\n      (typeDefs instanceof GraphQLSchema &&\n        stripResolversFromSchema(typeDefs)) ||\n      null\n\n    this[GRAPHIQL_FLAG] = true\n    this[TYPEDEFS_KEY] = normalizeSource(typeDefs)\n    this[MAP] = new WeakMap()\n    this[MAP].set(\n      wmkSchema,\n      typeDefs instanceof GraphQLSchema ? typeDefs : null\n    )\n    this[MAP].set(wmkResolvers, resolvers)\n    this[MAP].set(\n      wmkPreboundResolvers,\n      typeDefs instanceof Schemata ? typeDefs.prevResolverMaps : []\n    )\n\n    // Mark a schema passed to use in the constructor as an executable schema\n    // to prevent any replacement of the value by getters that generate a\n    // schema from the SDL\n    if (this[MAP].get(wmkSchema)) {\n      this[MAP].get(wmkSchema)[EXE] = true\n      this[MAP].get(wmkSchema)[Symbol.for('constructor-supplied-schema')] = true\n    }\n\n    // If buildResolvers is true, after the rest is already set and done, go\n    // ahead and build a new set of resolver functions for this instance\n    if (buildResolvers) {\n      if (buildResolvers === 'all') {\n        this[MAP].set(\n          wmkResolvers,\n          this.buildResolverForEachField(flattenResolvers)\n        )\n      }\n      else {\n        this[MAP].set(wmkResolvers, this.buildResolvers(flattenResolvers))\n      }\n    }\n  }\n\n  /**\n   * Symbol.species ensures that any String methods used on this instance will\n   * result in a Schemata instance rather than a String. NOTE: this does not\n   * work as expected in current versions of node. This bit of code here is\n   * basically a bit of future proofing for when Symbol.species starts working\n   * with String extended classes\n   *\n   * @type {Function}\n   */\n  static get [Symbol.species]() {\n    return Schemata\n  }\n\n  /**\n   * Redefine the iterator for Schemata instances so that they simply show the\n   * contents of the SDL/typeDefs.\n   *\n   * @type {Function}\n   */\n  get [Symbol.iterator]() {\n    return function*() {\n      yield this.toString()\n    }.bind(this)\n  }\n\n  /**\n   * Ensures that instances of Schemata report internally as Schemata object.\n   * Specifically using things like `Object.prototype.toString`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  /**\n   * Returns the AST nodes for this snippet of SDL. It will throw an error\n   * if the string is not valid SDL/IDL.\n   *\n   * @return {ASTNode} any valid ASTNode supported by GraphQL\n   */\n  get ast() {\n    return this.constructor.parse(this.sdl, false)\n  }\n\n  /**\n   * Retrieves the `graphiql` flag, which defaults to true. This flag can\n   * make setting up an endpoint from a Schemata instance easier with\n   * express-graphql\n   *\n   * @type {boolean}\n   */\n  get graphiql() {\n    return this[GRAPHIQL_FLAG]\n  }\n\n  /**\n   * Setter to alter the default 'true' flag to make an Schemata instance a\n   * valid single argument to functions like `graphqlHTTP()` from express\n   * GraphQL.\n   *\n   * NOTE: this flag means nothing to the Schemata class but might be useful in\n   * your project.\n   *\n   * @type {boolean} true if graphiql should be started; false otherwise\n   */\n  set graphiql(value) {\n    this[GRAPHIQL_FLAG] = value\n  }\n\n  /**\n   * Returns a GraphQLSchema object. Note this will fail and throw an error\n   * if there is not at least one Query, Subscription or Mutation type defined.\n   * If there is no stored schema, and there are resolvers, an executable\n   * schema is returned instead.\n   *\n   * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n   */\n  get schema() {\n    return this.#generateSchema()\n  }\n\n  /**\n   * Sets a GraphQLSchema object on the internal weak map store. If the value\n   * supplied is not truthy (i.e. null, undefined, or even false) then this\n   * method deletes any stored schema in the internal map. Otherwise, the\n   * supplied value is set on the map and subsequent get calls to `.schema`\n   * will return the value supplied.\n   *\n   * If there are bound resolvers on the supplied schema, a symbol denoting\n   * that the schema is an executable schema will be set to prevent it from\n   * being overwritten on subsequent get operations. The bound resolvers will\n   * be merged with the Schemata's resolvers object.\n   *\n   * If resolvers are subsequently set on the `Schemata` instance and the\n   * supplied schema does not have resolvers bound to it, subsequent get\n   * requests for the internal `.schema` may auto-generate a new one with\n   * bound resolvers. You have been warned. =)\n   *\n   * @param {GraphQLSchema} schema an instance of GraphQLSchema instance to\n   * store on the internal weak map. Any schema stored here will be modified\n   * by methods that do so.\n   */\n  set schema(schema) {\n    debug_log('[set .schema]: ', schema ? 'truthy' : 'falsey')\n    debug_trace('[set .schema] ', schema)\n\n    if (!schema) {\n      this[MAP].delete(wmkSchema)\n    }\n    else {\n      let schemaResolvers = stripResolversFromSchema(schema)\n\n      if (Object.keys(schemaResolvers).length) {\n        schema[EXE] = true\n\n        merge((this.resolvers = this.resolvers || {}), schemaResolvers)\n      }\n\n      this[MAP].set(wmkSchema, schema)\n    }\n  }\n\n  /**\n   * Retrieves the `schemaDirectives` value, which defaults to true. This\n   * value can make setting up an endpoint from a Schemata instance easier\n   * with apollo-server or graphql-yoga or compatible variants. See\n   * https://www.apollographql.com/docs/graphql-tools/schema-directives.html\n   * if you are using this value with apollo-server.\n   *\n   * @type {{[string]: Function}}\n   */\n  get schemaDirectives() {\n    return this[SCHEMA_DIRECTIVES]\n  }\n\n  /**\n   * Retrieves the `schemaDirectives` value, which defaults to true. This\n   * value can make setting up an endpoint from a Schemata instance easier\n   * with apollo-server or graphql-yoga or compatible variants. See\n   * https://the-guild.dev/graphql/tools/docs/schema-directives\n   * if you are using this value with apollo-server.\n   *\n   * @type {{[string]: Function}}\n   */\n  set schemaDirectives(value) {\n    this[SCHEMA_DIRECTIVES] = value\n  }\n\n  /**\n   * When a Schemata instance is merged with another GraphQLSchema, its\n   * resolvers get stored before they are wrapped in a function that updates\n   * the schema object it receives. This allows them to be wrapped safely at\n   * a later date should this instance be merged with another.\n   *\n   * @return {ExtendedResolverMap[]} an array of `ExtendedResolverMap`\n   * object instances\n   */\n  get prevResolverMaps() {\n    return this[MAP].get(wmkPreboundResolvers)\n  }\n\n  /**\n   * Sets the pre-bound resolver map objects as an array of\n   * `ExtendedResolverMap` object instances on this instance of Schemata\n   *\n   * @param {ExtendedResolverMap[]} maps an array of `ExtendedResolverMap`\n   * object instances\n   */\n  set prevResolverMaps(maps) {\n    this[MAP].set(wmkPreboundResolvers, maps)\n  }\n\n  /**\n   * Returns a GraphQLSchema object, pre-bound, to the associated resolvers\n   * methods in `.resolvers`. If there are no resolvers, this is essentially\n   * the same as asking for a schema instance using `.schema`. If the SDL\n   * this instance is built around is insufficient to generate a GraphQLSchema\n   * instance, then an error will be thrown.\n   *\n   * @deprecated use `.schema` instead; this simply proxies to that\n   * @type {GraphQLSchema}\n   */\n  get executableSchema() {\n    return this.schema\n  }\n\n  /**\n   * Returns the string this instance was generated with.\n   *\n   * @type {string}\n   */\n  get sdl() {\n    return this[TYPEDEFS_KEY]\n  }\n\n  /**\n   * Rewrites the typeDefs or SDL without any `extend type` definitions\n   * and returns the modified instance.\n   *\n   * @type {Schemata}\n   */\n  flattenSDL() {\n    if (this.schema) {\n      this[TYPEDEFS_KEY] = printSchema(this.schema)\n    }\n\n    return this\n  }\n\n  /**\n   * Returns the regenerated SDL representing the Schema object on this\n   * Schemata instance. It does not modify the schemata object instance\n   * in any way.\n   *\n   * @type {string}\n   */\n  get flatSDL() {\n    let sdl = this[TYPEDEFS_KEY]\n\n    if (this.schema) {\n      sdl = printSchema(this.schema)\n    }\n\n    return sdl\n  }\n\n  /**\n   * A synonym or alias for `.sdl`. Placed here for the express purpose of\n   * destructuing when used with Apollo's makeExecutableSchema or other\n   * libraries expecting values of the same name\n   *\n   * i.e.\n   *   // sdl.typeDefs and sdl.resolvers will be where the function expects\n   *   let schema = require('graphql-tools').makeExecutableSchema(sdl)\n   *\n   * @type {string}\n   */\n  get typeDefs() {\n    return this.sdl\n  }\n\n  /**\n   * Walks the types defined in the sdl for this instance of Schemata and\n   * returns an object mapping for those definitions. Given a schema such as\n   * ```\n   * type A {\n   *   a: String\n   *   b: [String]\n   *   c: [String]!\n   * }\n   * type Query {\n   *   As(name: String): [A]\n   * }\n   * ```\n   * a JavaScript object with properties such as the following will be\n   * returned\n   * ```\n   * {\n   *   Query: {\n   *     As: { type: '[A]', args: [{ name: 'String' }] }\n   *   },\n   *   A: {\n   *     a: { type: 'String', args: [] },\n   *     b: { type: '[String]', args: [] },\n   *     c: { type: '[String]!', args: [] }\n   *   }\n   * }\n   * ```\n   *\n   * @type {object}\n   */\n  get types() {\n    let types = {}\n\n    this.forEachTypeField((t,tn,td,f,fn,fa,fd,schema,c) => {\n      let ast = parse(printType(t)).definitions[0]\n      let fieldAST = ast.fields.filter((o,i,a) => o.name.value == fn)\n      let fieldType = fieldAST.length && typeFromAST(schema, fieldAST[0].type)\n      let args = []\n\n      if (fa?.length) {\n        for (let {name, type} of fa) {\n          args.push({ [name]: type.toString() })\n        }\n      }\n\n      (types[tn] = types[tn] || {})[fn] = {\n        type: fieldType.toString(),\n        args: args\n      }\n    })\n\n    return types\n  }\n\n  /**\n   * An internal call to buildResolvers(true), thereby requesting a flattened\n   * resolver map with Query, Mutation and Subscription fields exposed as root\n   * objects the way the Facebook reference implementation expects\n   *\n   * @return {ResolverMap} an object of functions or an empty object otherwise\n   */\n  get rootValue() {\n    return this.buildResolvers(true)\n  }\n\n  /**\n   * Returns any resolvers function object associated with this instance.\n   *\n   * @return {ResolverMap} an object containing field resolvers or null if none\n   * are stored within\n   */\n  get resolvers() {\n    return this[MAP].get(wmkResolvers)\n  }\n\n  /**\n   * Parses the resolvers object, if present, for any items that need to\n   * be applied after the schema is constructed.\n   *\n   * @return {ResolverInfo[]} an array of objects to process or an empty\n   * array if there is nothing to work on\n   */\n  get resolverInfo() {\n    return extractResolverInfo(this.resolvers)\n  }\n\n  /**\n   * A method to fetch a particular field resolver from the schema represented\n   * by this Schemata instance.\n   *\n   * @param {string} type the name of the type desired\n   * @param {string} field the name of the field containing the resolver\n   * @return {Function} the function resolver for the type and field in\n   * question\n   */\n  schemaResolverFor(type, field) {\n    if (!this.resolvers || !Object.keys(this.resolvers).length || !this.valid) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n    let resolve = (_field?.resolve) || null\n\n    return resolve\n  }\n\n  /**\n   * Builds a schema based on the SDL in the instance and then parses it to\n   * fetch a named field in a named type. If either the type or field are\n   * missing or if the SDL cannot be built as a schema, null is returned.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  schemaFieldByName(type, field) {\n    if (!this.validSchema || !this.schema) {\n      return null\n    }\n\n    let _type = this.schema.getType(type)\n    let _field = (_type.getFields() && _type.getFields()[field]) || null\n\n    return _field\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * parsed and searched for a type by name.\n   *\n   * @param {string} type the name of a type\n   * @return {ASTNode} the field reference in the type and field supplied\n   */\n  astTypeByName(type) {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n\n    return _type\n  }\n\n  /**\n   * For SDL that doesn't properly build into a GraphQLSchema, it can still be\n   * searched for a type and field.\n   *\n   * @param {string} type the name of a type\n   * @param {string} field the name of a field contained in the above type\n   * @return {FieldNode} the field reference in the type and field supplied\n   */\n  astFieldByName(type, field) {\n    if (!this.validSDL) {\n      return null\n    }\n\n    let _type = this.ast.definitions.find(f => f.name.value === type)\n    let _field =\n      (_type?.fields.find(f => f.name.value === field)) || null\n\n    return _field\n  }\n\n  /**\n   * Walks the AST for this SDL string and checks for the names of the fields\n   * of each of the root types; Query, Mutation and Subscription. If there are\n   * no root types defined, false is returned.\n   *\n   * If there is at least one root type *and* some resolvers *and* at least one\n   * of the fields of at least one root type is present in the root of the\n   * resolvers map, true is returned. Otherwise, false.\n   *\n   * @return {boolean} true if the defined resolvers have at least one root\n   * type field as a resolver on the root of the resolver map; false otherwise.\n   */\n  get hasFlattenedResolvers() {\n    let asts = (this.validSDL && this.ast.definitions) || null\n\n    if (!asts || !this.resolvers) {\n      return false\n    }\n\n    let query = asts.find(f => f.name.value == 'Query')\n    let mutation = asts.find(f => f.name.value == 'Mutation')\n    let subscription = asts.find(f => f.name.value == 'Subscription')\n    let resolvers = this.resolvers\n\n    if (!query && !mutation && !subscription) {\n      return false\n    }\n\n    for (let type of [query, mutation, subscription]) {\n      if (!type?.fields) {\n        continue\n      }\n\n      for (let field of type.fields) {\n        if (field.name.value in resolvers) {\n          return true\n        }\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Merging Schematas are a common feature in the modern world of GraphQL.\n   * Especially when there are multiple teams working in tandem. This feature\n   * supports merging of types, extended types, interfaces, enums, unions,\n   * input object types and directives for all of the above.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ConflictResolvers} conflictResolvers an object containing up to\n   * four methods, each describing how to handle a conflict when an associated\n   * type of conflict occurs. If no object or method are supplied, the right\n   * hande value always takes precedence over the existing value; replacing it\n   * @return {Schemata} a new instance of Schemata\n   */\n  mergeSDL(\n    schemaLanguage,\n    conflictResolvers = DefaultConflictResolvers\n  ) {\n    let source = normalizeSource(schemaLanguage, true)\n\n    if (!source) {\n      throw new Error(inline`\n        The call to mergeSDL(schemaLanguage, conflictResolvers) received an\n        invalid value for schemaLanguage. Please check your code and try again.\n        Received ${schemaLanguage}.\n      `)\n    }\n\n    let lAST = this.ast\n    let rAST = source.ast\n    let _scalarFns = {}\n\n    // Ensure we have default behavior with any custom behavior assigned\n    // atop the default ones should only a partial custom be supplied.\n    conflictResolvers = merge(DefaultConflictResolvers, conflictResolvers)\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (rType?.kind?.endsWith('Extension')) {\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - 9) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      case 'EnumTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('values', lType, rType, conflictResolvers)\n        break\n\n      case 'UnionTypeDefinition':\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('types', lType, rType, conflictResolvers)\n        break\n\n      case 'ScalarTypeDefinitionNode': {\n        let lScalar\n        let lScalarConfig\n        let rScalar\n        let rScalarConfig\n        let resolver\n\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n\n        if (this.schema) {\n          lScalar = this.schema.getType(lType.name.value)\n          lScalarConfig = (lScalar?._scalarConfig) || null\n        }\n\n        if (source.schema) {\n          rScalar = source.schema.getType(rType.name.value)\n          rScalarConfig = (rScalar?._scalarConfig) || null\n        }\n\n        resolver = (conflictResolvers.scalarMergeResolver ||\n            DefaultConflictResolvers.scalarMergeResolver)(\n          lType,\n          lScalarConfig,\n          rType,\n          rScalarConfig\n        )\n\n        if (resolver) {\n          _scalarFns[lType.name.value] = _scalarFns[lType.name.value] || {}\n          _scalarFns[lType.name.value] = resolver\n        }\n        break\n      }\n\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n      default:\n        combineTypeAndSubType('directives', lType, rType, conflictResolvers)\n        combineTypeAndSubType('fields', lType, rType, conflictResolvers)\n        break\n      }\n    }\n\n    let merged = Schemata.from(this.constructor.gql.print(lAST))\n\n    if (Object.keys(_scalarFns).length) {\n      for (let typeName of Object.keys(_scalarFns)) {\n        merged.schema.getType(typeName)._scalarConfig = _scalarConfig[typeName]\n      }\n    }\n\n    return merged\n  }\n\n  /**\n   * Paring down Schematas can be handy for certain types of schema stitching.\n   * The SDL passed in and any associated resolvers will be removed from\n   * a copy of the SDL in this Schemata instance represents and the resolver\n   * map passed in.\n   *\n   * @param {SchemaSource} schemaLanguage an instance of Schemata, a string of\n   * SDL, a Source instance of SDL, a GraphQLSchema or ASTNode that can be\n   * printed as an SDL string\n   * @param {ResolverMap} resolverMap an object containing resolver functions,\n   * from either those set on this instance or those in the resolverMap added in\n   * @return {Schemata} a new Schemata instance with the changed values set\n   * on it\n   */\n  pareSDL(\n    schemaLanguage,\n    resolverMap = null\n  ) {\n    let source = normalizeSource(schemaLanguage, true)\n    if (!source) {\n      throw new Error(inline`\n        In the call to pareSDL(schemaLanguage), the supplied value for\n        \\`schemaLanguage\\` could not be parsed.\n      `)\n    }\n\n    if (schemaLanguage instanceof GraphQLSchema && !resolverMap) {\n      resolverMap = stripResolversFromSchema(schemaLanguage)\n    }\n\n    let resolvers = merge({}, resolverMap || this.resolvers || {})\n    let lAST = this.ast\n    let rAST = source.ast\n\n    for (let rType of rAST.definitions) {\n      let lType = lAST.definitions.find(a => a.name.value == rType.name.value)\n\n      if (rType?.kind?.endsWith('Extension')) {\n        let len = 'Extension'.length\n\n        rType = merge({}, rType)\n        rType.kind =\n          rType.kind.substring(0, rType.kind.length - len) + 'Definition'\n      }\n\n      if (!lType) {\n        lAST.definitions.push(rType)\n        continue\n      }\n\n      switch (lType.kind) {\n      case 'EnumTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('values', lType, rType, resolvers)\n\n        if (!lType.values.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'UnionTypeDefinition':\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('types', lType, rType, resolvers)\n\n        if (!lType.types.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n\n      case 'ScalarTypeDefinitionNode': {\n        let index = lAST.definitions.indexOf(lType)\n\n        if (index !== -1) {\n          lAST.definitions.splice(index, 1)\n        }\n        break\n      }\n\n      case 'ObjectTypeDefinition':\n      case 'ObjectTypeDefinitionExtension':\n      case 'InterfaceTypeDefinition':\n      case 'InterfaceTypeDefinitionExtension':\n      case 'InputObjectTypeDefinition':\n      case 'InputObjectTypeDefinitionExtension':\n      default:\n        pareTypeAndSubType('directives', lType, rType, resolvers)\n        pareTypeAndSubType('fields', lType, rType, resolvers)\n\n        if (!lType.fields.length) {\n          let index = lAST.definitions.indexOf(lType)\n\n          if (index !== -1) {\n            lAST.definitions.splice(index, 1)\n          }\n        }\n        break\n      }\n    }\n\n    let result = Schemata.from(this.constructor.gql.print(lAST), resolvers)\n    result.#generateSchema()\n\n    return result\n  }\n\n  /**\n   * A new Schemata object instance with merged schema definitions as its\n   * contents as well as merged resolvers and newly bound executable schema are\n   * all created in this step and passed back. The object instance itself is\n   * not modified\n   *\n   * Post merge, the previously stored and merged resolvers map are are applied\n   * and a new executable schema is built from the ashes of the old.\n   *\n   * @param {SchemaSource} schema an instance of GraphQLSchema to merge\n   * @param {MergeOptionsConfig} config an object defining how conflicts should\n   * be resolved. This defaults to `DefaultMergeOptions`.\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  merge(\n    schema,\n    config = DefaultMergeOptions\n  ) {\n    if (!schema) {\n      throw new Error(inline`\n        In the call to mergeSchema(schema), ${schema} was received as a value\n        and the code could not proceed because of it. Please check your code\n        and try again\n      `)\n    }\n\n    // Step0: Ensure we have all the defaults for config and schema\n    schema = normalizeSource(schema, true)\n\n    if (config !== DefaultMergeOptions) {\n      let mergedConfig = merge({}, DefaultMergeOptions)\n      config = merge(mergedConfig, config)\n    }\n\n    // Step1: Merge SDL; quit at this point if there are no resolvers\n    let left = Schemata.from(this, undefined, true)\n    let right = Schemata.from(schema, undefined, true)\n    let merged = left.mergeSDL(right, config.conflictResolvers)\n\n    // If neither schemata instance has a resolver, there is no reason\n    // to continue. Return the merged schemas and call it a day.\n    if (\n      (!left.resolvers || !Object.keys(left.resolvers).length) &&\n      (!right.resolvers || !Object.keys(right.resolvers).length)\n    ) {\n      return merged\n    }\n\n    // Step2: Backup resolvers from left, right, or both\n    let prevMaps = (left.prevResolverMaps || []).concat(\n      right.prevResolverMaps || [],\n      ExtendedResolverMap.from(left),\n      ExtendedResolverMap.from(right)\n    )\n    merged.prevResolverMaps = prevMaps\n\n    // Step3: Merge resolvers\n    let mergeResolvers = {}\n\n    if (prevMaps?.length) {\n      mergeResolvers = prevMaps.reduce((p, c, i, a) => {\n        return merge(p, c.resolvers || {})\n      }, {})\n    }\n    else {\n      merge(mergeResolvers, left.resolvers)\n      merge(mergeResolvers, right.resolvers)\n    }\n    merged.resolvers = mergeResolvers\n\n    // Step 4: Trigger a new schema creation\n    if (config.createMissingResolvers) {\n      merged.resolvers = merged.buildResolverForEachField()\n    }\n    merged.clearSchema()\n    merged.#generateSchema()\n\n    // Step5: Wrap resolvers\n    if (config.injectMergedSchema) {\n      merged.forEachField(\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (field.resolve) {\n            field.resolve = ExtendedResolver.SchemaInjector(\n              field.resolve,\n              merged.schema\n            )\n\n            if (!merged.resolvers[typeName]) {\n              merged.resolvers[typeName] = {}\n            }\n\n            merged.resolvers[typeName][fieldName] = field.resolve\n          }\n        }\n      )\n\n      // Do this once more to ensure we are using the modified resolvers\n      merged.clearSchema()\n      merged.#generateSchema()\n    }\n\n    // Step6: Return final merged product\n    return merged\n  }\n\n  /**\n   * Shortcut for the merge() function; mergeSDL still exists as an entity of\n   * itself, but merge() will invoke that function as needed to do its job and\n   * if there aren't any resolvers to consider, the functions act identically.\n   *\n   * @see merge\n   *\n   * @param {GraphQLSchema | Schemata} schema an instance of GraphQLSchema to\n   * merge. Can be either a GraphQLSchema or a Schemata instance\n   * @param {MergeOptionsConfig} config an object defining how conflicts should\n   * be resolved. This defaults to `DefaultMergeOptions`.\n   * @return {Schemata} a new instance of Schemata with a merged schema string,\n   * merged resolver map and newly bound executable schema attached are all\n   * initiated\n   */\n  mergeSchema(\n    schema,\n    config = DefaultMergeOptions\n  ) {\n    return this.merge(schema, config)\n  }\n\n  /**\n   * Given a schema, based on the Schemata this object is based on, walk it and\n   * build up a resolver map. This function will always return a non-null\n   * object. It will be empty if there are either no resolvers to be found\n   * in the schema or if a valid schema cannot be created.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an Object, it will be merged in normally\n   * with merge.\n   * @param {ResolverMap[]} extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolvers(flattenRootResolversOrFirstParam, ...extendWith) {\n    let schemata = Schemata.from(this.sdl, this.resolvers)\n    let resolvers = merge({},\n      stripResolversFromSchema(schemata.schema) || schemata.resolvers || {}\n    )\n\n    // Next check to see if we are flattening or simply extending\n    if (typeof flattenRootResolversOrFirstParam === 'boolean') {\n      for (let rootType of ['Query', 'Mutation', 'Subscription']) {\n        if (flattenRootResolversOrFirstParam) {\n          if (resolvers[rootType]) {\n            for (let field of Object.keys(resolvers[rootType])) {\n              resolvers[field] = resolvers[rootType][field]\n              delete resolvers[rootType][field]\n            }\n\n            delete resolvers[rootType]\n          }\n        }\n        else {\n          for (let field of Object.keys(resolvers)) {\n            try {\n              debug_log('[buildResolvers()] finding field in schema')\n              if (schemata.schemaFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n            catch (error) {\n              debug_log(dedent`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\`\n                  rootType  %O\n                  field     %O\n                  resolvers %O\n              `, rootType, field, resolvers)\n              debug_trace(dedent`\n                [buildResolvers()] Falling back to \\`astFieldByName()\\` due to\n                  rootType  %O\n                  field     %O\n                  resolvers %O\n                  error     %O\n              `,\n                rootType,\n                field,\n                resolvers,\n                error\n              )\n\n              if (schemata.astFieldByName(rootType, field)) {\n                resolvers[rootType] = resolvers[rootType] || {}\n                resolvers[rootType][field] = resolvers[field]\n                delete resolvers[field]\n              }\n            }\n          }\n        }\n      }\n    }\n    else {\n      resolvers = merge(resolvers || {}, flattenRootResolversOrFirstParam || {})\n    }\n\n    // Finally extend with any remaining arguments\n    if (extendWith.length) {\n      for (let item of extendWith) {\n        resolvers = merge(resolvers || {}, item || {})\n      }\n    }\n\n    return resolvers\n  }\n\n  /**\n   * From time to time it makes more sense to wrap every possible resolver\n   * mapping in given schema. Getting a handle to each fields resolver and\n   * or substituting missing ones with GraphQL's defaultFieldResolver can\n   * be a tiresome affair. This method walks the schema for you and returns\n   * any previously defined resolvers alongside defaultFieldResolvers for\n   * each possible field of every type in the schema.\n   *\n   * If a schema cannot be generated from the SDL represented by the instance\n   * of Schemata, then an error is thrown.\n   *\n   * @param {boolean|ResolverMap} flattenRootResolversOrFirstParam if this\n   * value is boolean, and if this value is true, the resolvers from Query,\n   * Mutation and Subscription types will be flattened to the root of the\n   * object. If the first parametr is an ResolverMap, it will be merged in\n   * normally with merge.\n   * @param {ResolverMap[]} extendWith an unlimited array of objects\n   * that can be used to extend the built resolver map.\n   * @return {ResolverMap} a resolver map; i.e. an object of resolver functions\n   */\n  buildResolverForEachField(flattenRootResolversOrFirstParam, ...extendWith) {\n    if (!this.schema) {\n      throw new Error(inline`\n        buildResolverForEachField() cannot be called unless there is enough\n        valid SDL in the instance to construct a schema. Please check your\n        code!\n      `)\n    }\n\n    let interim = Schemata.from(this.sdl, this.resolvers)\n    let r = {}\n\n    interim.forEachField(\n      (\n        type,\n        typeName,\n        typeDirectives,\n        field,\n        fieldName,\n        fieldArgs,\n        fieldDirectives,\n        schema,\n        context\n      ) => {\n        // Ensure the path to the type in question exists before continuing\n        // onward\n        (r[typeName] = r[typeName] || {})[fieldName] =\n          (r[typeName][fieldName] || {})\n\n        r[typeName][fieldName] = field.resolve || defaultFieldResolver\n      }\n    )\n\n    interim.resolvers = r\n\n    return interim.buildResolvers(\n      flattenRootResolversOrFirstParam,\n      ...extendWith\n    )\n  }\n\n  /**\n   * A method to determine if an executable schema is attached to this Schemata\n   * instance. It does so by walking the schema fields via `buildResolvers()`\n   * and reporting whether there is anything inside the results or not.\n   *\n   * @type {boolean}\n   */\n  get hasAnExecutableSchema() {\n    return Object.keys(this.buildResolvers()).length > 0\n  }\n\n  /**\n   * If the `.sdl` property is valid SDL/IDL and can generate valid AST nodes\n   * this function will return true. It will return false otherwise.\n   *\n   * @type {boolean}\n   */\n  get validSDL() {\n    try {\n      this.constructor.gql.parse(this.sdl)\n      debug_log('[get .validSDL] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSDL] false')\n      debug_trace('[get .validSDL] ', e)\n      return false\n    }\n  }\n\n  /**\n   * If the `.schema` property is valid SDL/IDL and can generate a valid\n   * GraphQLSchema, this function will return true. It will return false\n   * otherwise.\n   *\n   * @type {boolean}\n   */\n  get validSchema() {\n    try {\n      this.#generateSchema()\n      debug_log('[get .validSchema] true')\n      return true\n    }\n    catch (e) {\n      debug_log('[get .validSchema] false')\n      debug_trace('[get .validSchema] ', e)\n      return false\n    }\n  }\n\n  /**\n   * Returns true if the string underlying this instance represents valid SDL\n   * that can be both converted to AST nodes or a valid GraphQLSchema instance\n   *\n   * @type {boolean}\n   */\n  get valid() {\n    return this.validSDL && this.validSchema\n  }\n\n  /**\n   * If the internal resolvers object needs to be changed after creation, this\n   * method allows a way to do so. Setting the value to `null` is equivalent\n   * to removing any stored value. Finally the contents are stored in a weak\n   * map so its contents are not guaranteed over a long period of time.\n   *\n   * @type {ResolverMap}\n   */\n  set resolvers(resolvers) {\n    this[MAP].set(wmkResolvers, resolvers)\n    this.clearSchema()\n  }\n\n  /**\n   * Removes the resolver map associated with this Schemata instance\n   */\n  clearResolvers() {\n    this.resolvers = null\n  }\n\n  /**\n   * Removes the schema stored with this Schemata instance\n   */\n  clearSchema() {\n    this.schema = null\n  }\n\n  /**\n   * Returns the underlying string passed or generated in the constructor when\n   * inspected in the nodeJS REPL.\n   *\n   * @return {string} returns the underlying SDL/IDL string this Schemata\n   * instance is based on.\n   */\n  [Util.inspect.custom]() {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} returns the underlying SDL/IDL string this Schemata\n   * instance is based on.\n   */\n  toString() {\n    return this.sdl\n  }\n\n  /**\n   * The same as `inspect()`, `toString()`, and `valueOf()`. This method\n   * returns the underlying string this class instance was created on.\n   *\n   * @return {string} returns the underlying SDL/IDL string this Schemata\n   * instance is based on.\n   */\n  valueOf() {\n    return this.sdl\n  }\n\n  /**\n   * Iterates over the values contained in a Schema's typeMap. If a desired\n   * value is encountered, the supplied callback will be invoked. The values are\n   * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally\n   * HIDDEN is another value that can be bitmasked together for a varied result.\n   * HIDDEN exposes the values in the schema typemap that begin with a double\n   * underscore.\n   *\n   * The signature for the function callback is as follows:\n   * (\n   *   type: unknown,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>\n   *   schema: GraphQLSchema,\n   *   context: unknown,\n   * ) => void\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on.\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object,\n   *                      passed to the call to `makeExecutableSchema()`\n   *                      or `graphql()`\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {number} types a bitmask of one or more of the constants defined\n   * above. These can be OR'ed together and default to TYPES.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachOf(fn, context, types, suppliedSchema = null) {\n    let schema = suppliedSchema || this.schema\n\n    forEachOf(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated over and returned.\n   */\n  forEachType(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to input object types.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this Schemata\n   * @return {GraphQLSchema} a new schema is generated from this Schemata,\n   * iterated\n   * over and returned.\n   */\n  forEachInputObjectType(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, INPUT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to unions.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachUnion(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, UNIONS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to enums.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachEnum(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, ENUMS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to interfaces.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachInterface(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, INTERFACES, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to types.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL,\n   * iterated over and returned.\n   */\n  forEachScalar(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, SCALARS, suppliedSchema)\n  }\n\n  /**\n   * Shortcut to `forEachOf()` specific to all root types; Query, Mutation and\n   * Subscription that exist within the schema.\n   *\n   * @see #forEachOf\n   *\n   * @param {ForEachOfResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachRootType(fn, context, suppliedSchema = null) {\n    return this.forEachOf(fn, context, ROOT_TYPES, suppliedSchema)\n  }\n\n  /**\n   * An extension of `forEachOf` that targets the fields of the types in the\n   * schema's typeMap. This function provides more detail and allows greater\n   * access to any associated `context` than the function of the same name\n   * provided by the `graphql-tools` library.\n   *\n   * The signature for the callback function is as follows\n   *\n   * (\n   *   type: unknown,\n   *   typeName: string,\n   *   typeDirectives: Array<GraphQLDirective>,\n   *   field: unknown,\n   *   fieldName: string,\n   *   fieldArgs: Array<GraphQLArgument>,\n   *   fieldDirectives: Array<GraphQLDirective>,\n   *   schema: GraphQLSchema,\n   *   context: unknown\n   * ) => void\n   *\n   * Where\n   *\n   * Where:\n   *   `type`           - the object instance from within the `GraphQLSchema`\n   *   `typeName`       - the name of the object; \"Query\" for type Query and\n   *                      so on\n   *   `typeDirectives` - an array of directives applied to the object or an\n   *                      empty array if there are none applied.\n   *   `field`          - the field in question from the type\n   *   `fieldName`      - the name of the field as a string\n   *   `fieldArgs`      - an array of arguments for the field in question\n   *   `fieldDirectives`- an array of directives applied to the field or an\n   *                      empty array should there be no applied directives\n   *   `schema`         - an instance of `GraphQLSchema` over which to iterate\n   *   `context`        - usually an object, and usually the same object, passed\n   *                      to the call to `makeExecutableSchema()` or `graphql()`\n   *\n   * Types, or BitmaskedType values, are defined as the following bitmask\n   * constant values. They help the function understand which GraphQL subtype\n   * should be iterated over. It defaults to ALL.\n   *\n   * const ALL = 1\n   * const TYPES = 2\n   * const INTERFACES = 4\n   * const ENUMS = 8\n   * const UNIONS = 16\n   * const SCALARS = 32\n   * const ROOT_TYPES = 64\n   * const INPUT_TYPES = 128\n   * const HIDDEN = 256\n   *\n   * @param {ForEachFieldResolver} fn a function with a signature defined above\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {BitmaskedType?} types one of the BitmaskedType values. See above.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} a new schema is generated from this SDL, iterated\n   * over and returned.\n   */\n  forEachField(fn, context, types = ALL, suppliedSchema = null): GraphQLSchema {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, types)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLObjectTypes specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachTypeField(fn, context, suppliedSchema = null) {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, TYPES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInterfaceType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInterfaceField(fn, context, suppliedSchema = null) {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INTERFACES)\n\n    return schema\n  }\n\n  /**\n   * `forEachField()` shortcut focusing on GraphQLInputObjectType specifically.\n   *\n   * @param {ForEachFieldResolver} fn a callback function that is invoked for\n   * each field of any GraphQLObjectType found\n   * @param {unknown} context usually an object but any mixed value the denotes\n   * some shared context as is used with the schema during normal runtime.\n   * @param {GraphQLSchema?} suppliedSchema an optional schema to use rather\n   * than the one created or stored internally generated from this SDL\n   * @return {GraphQLSchema} either the supplied GraphQLSchema or one generated\n   * to facilitate the task\n   */\n  forEachInputObjectField(fn, context, suppliedSchema = null) {\n    let schema = suppliedSchema || this.schema\n\n    forEachField(schema, fn, context, INPUT_TYPES)\n\n    return schema\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphqlSync()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   * @template TSource the value being resolved. This is the object that needs\n   * to be typed.\n   * @template TArgs the type of the arguments passed to the field in the\n   * GraphQL query.\n   * @template TContext the context object passed to the resolver. This can\n   * contain useful data like the current user or database connection.\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {unknown?} contextValue a bit of shared context to pass to resolvers\n   * @param {ObjMap?} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap?} rootValue provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string?} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<TSource, TArgs, TContext>?} fieldResolver A\n   * resolver function to use when one is not provided by the schema. If not\n   * provided, the default field resolver is used (which looks for a value or\n   * method on the source value with the field's name).\n   * @param {GraphQLTypeResolver<TSource,TContext>?} typeResolver A resolver is\n   * a function type used to determine the concrete type of an object when\n   * resolving an interface or union type.\n   * @return {ExecutionResult} the requested results. An error is thrown if\n   * the results could not be fulfilled or invalid input/output was specified.\n   */\n  run(\n    query,\n    contextValue,\n    variableValues,\n    rootValue,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  ) {\n    return this.constructor.gql.graphqlSync({\n      schema: this.schema,\n      source: query,\n      rootValue: this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n      typeResolver\n    })\n  }\n\n  /**\n   * Wrapper for `require('graphql').graphql()` that automatically passes\n   * in the internal `.schema` reference as the first parameter.\n   *\n   * @template TSource the value being resolved. This is the object that needs\n   * to be typed.\n   * @template TArgs the type of the arguments passed to the field in the\n   * GraphQL query.\n   * @template TContext the context object passed to the resolver. This can\n   * contain useful data like the current user or database connection.\n   * @param {string|Source} query A GraphQL language formatted string\n   * representing the requested operation.\n   * @param {unknown?} contextValue a bit of shared context to pass to resolvers\n   * @param {Object?} variableValues A mapping of variable name to runtime value\n   * to use for all variables defined in the requestString.\n   * @param {ResolverMap?} The value provided as the first argument to\n   * resolver functions on the top level type (e.g. the query object type).\n   * @param {string?} operationName The name of the operation to use if\n   * requestString contains multiple possible operations. Can be omitted if\n   * requestString contains only one operation.\n   * @param {GraphQLFieldResolver<TSource, TArgs, TContext>?} fieldResolver A\n   * resolver function to use when one is not provided by the schema. If not\n   * provided, the default field resolver is used (which looks for a value or\n   * method on the source value with the field's name).\n   * @param {GraphQLTypeResolver<TSource,TContext>?} typeResolver A resolver is\n   * a function type used to determine the concrete type of an object when\n   * resolving an interface or union type.\n   * @return {Promise<ExecutionResult>} a Promise contianing the requested\n   * results\n   */\n  async runAsync(\n    query,\n    contextValue,\n    variableValues,\n    rootValue,\n    operationName,\n    fieldResolver,\n    typeResolver,\n  ) {\n    return this.constructor.gql.graphql({\n      schema: this.schema,\n      source: query,\n      rootValue: this.resolvers || rootValue,\n      contextValue,\n      variableValues,\n      operationName,\n      fieldResolver,\n      typeResolver\n    })\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when building a schema\n   * from the string SDL representation of a given instance.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} [showError=false] true if the error should be thrown,\n   * false if the error should be silently suppressed\n   * @param {BuildSchemaOptions&ParseOptions} [schemaOpts=undefined] for\n   * advanced users, passing through additional buildSchema() options can be\n   * done here\n   * @return {GraphQLSchema} null if an error occurs and errors are not\n   * surfaced or a valid GraphQLSchema object otherwise\n   */\n  static buildSchema(sdl, showError = false, schemaOpts = undefined) {\n    try {\n      debug_log('[static buildSchema()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static buildSchema()] building schema')\n      return this.gql.buildSchema(source, schemaOpts)\n    }\n    catch (e) {\n      debug_log('[static buildSchema()] failed to build!')\n      debug_trace('[static buildSchema()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when parsing Schemata for\n   * ASTNodes. If showError is true, any caught errors are thrown once again.\n   *\n   * @param {SchemaSource} sdl an instance of Schemata, a string of SDL, a\n   * Source instance of SDL, a GraphQLSchema or ASTNode that can be printed as\n   * an SDL string\n   * @param {boolean} [showError=false] if true, any caught errors will be thrown once\n   * again\n   * @param {boolean} [enhance=true] a generator keyed with `Symbol.iterator` is set\n   * on the resulting astNode object allowing the resulting `.ast` value to\n   * be iterable. The code iterates over each definition of the resulting\n   * DocumentNode. This behavior defaults to true and should not have any ill\n   * effects on code expecting vanilla ASTNode objects\n   * @return {ASTNode} null if an error occurs and errors are suppressed,\n   * a top level Document ASTNode otherwise\n   */\n  static parse(sdl, showError = false, enhance = true) {\n    try {\n      debug_log('[static parse()] normalizing source')\n      let source = normalizeSource(sdl)\n\n      debug_log('[static parse()] parsing')\n      let node = this.gql.parse(source)\n\n      if (enhance) {\n        debug_log('[static parse()] enhancing')\n        node[Symbol.iterator] = function*() {\n          for (let node of this.definitions) {\n            yield node\n          }\n        }\n      }\n\n      return node\n    }\n    catch (e) {\n      debug_log('[static parse()] failed to parse')\n      debug_trace('[static parse()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A little wrapper used to catch any errors thrown when printing an ASTNode\n   * to string form using `require('graphql').print()`. If `showError` is true\n   * any thrown errors will be rethrown, otherwise null is returned instead.\n   *\n   * Should all go as planned, an instance of Schemata wrapped with the printed\n   * SDL will be returned.\n   *\n   * @since 1.7\n   *\n   * @param {ASTNode|GraphQLSchema} ast an ASTNode, usually a\n   * DocumentNode generated with some version of `require('graphql').parse()`.\n   * If an instance of GraphQLSchema is supplied, `printSchema()` is used\n   * instead of `print()`\n   * @param {boolean?} [showError=false] if true, any caught errors will be\n   * thrown once again\n   * @return {Schemata} null if an error occurs (and showError is false)\n   * or an instance of Schemata wrapping the resulting SDL string from the\n   * print operation\n   */\n  static print(ast, showError = false) {\n    try {\n      let source\n\n      if (ast instanceof GraphQLSchema) {\n        debug_log('[static print()] printing schema')\n        source = this.gql.printSchema(ast)\n      }\n      else {\n        debug_log('[static print()] printing ASTNode')\n        source = this.gql.print(ast)\n      }\n\n      debug_log('[static print()] creating new Schemata from print')\n      return Schemata.from(source)\n    }\n    catch (e) {\n      debug_log('[static print()] failed to print')\n      debug_trace('[static print()] ', e)\n      if (showError) {\n        throw e\n      }\n      return null\n    }\n  }\n\n  /**\n   * A simple pass thru used within the class to reference graphql methods\n   * and classes.\n   *\n   * @return {object} the results of `require('graphql')`\n   */\n  static get gql() {\n    return require('graphql')\n  }\n\n  /**\n   * Shorthand way of invoking `new Schemata()`\n   *\n   * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n   * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n   * as an SDL string\n   * @param {ResolverMap} [resolvers=null] an object containing field resolvers\n   * for for the schema represented with this string.\n   * @param {boolean|string} [buildResolvers=false] if this flag is set to\n   * true, build a set of resolvers after the rest of the instance is\n   * initialized and set the results on the `.resolvers` property of the newly\n   * created instance. If buildResolvers is the string \"all\", then a resolver\n   * for each field not defined will be returned with a `defaultFieldResolver`\n   * as its value\n   * @param {boolean} [flattenResolvers=false] if true, and if `buildResolvers`\n   * is true, then make an attempt to flatten the root types to the base of the\n   * resolver map object.\n   * @return {Schemata} an instance of Schemata\n   */\n  static from(\n    typeDefs,\n    resolvers = null,\n    buildResolvers = false,\n    flattenResolvers = false\n  ) {\n    return new this(typeDefs, resolvers, buildResolvers, flattenResolvers)\n  }\n\n  /**\n   * Shorthand way of invoking `new Schemata()` after the function reads the\n   * contents of the file specified at the supplied path.\n   *\n   * @param {string} path path to the file to read the contents of\n   * @return {Schemata} an instance of Schemata\n   */\n  static async fromContentsOf(path) {\n    const resolved = pathResolve(path)\n    const contents = (await readFile(resolved))?.toString()\n\n    return Schemata.from(contents)\n  }\n\n  /**\n   * Walks a given directory and its subdirectories to find any files with the\n   * `.graphql/.sdl/.type[dD]ef` extension were found. If an adjacent, or\n   * otherwise specified, file with a `.js/.cjs/.mjs` extension is found,\n   * and successfully read, then its resolvers are added to the final Schemata\n   * output. A schema with any associated actionable resolver is returned as\n   * and executable schema.\n   *\n   * @param {string} path a file path to the directory where scanning should\n   * start to occur.\n   * @param {Object} [options=undefined] an object that allows the developer\n   * to configure how conflicts are resolved (rather than just taking the\n   * latest value as an override to any previously existing resolver) as well\n   * as a way to specify where resolver files of the same name as the\n   * .graphql/.sdl/.typeDef file should exist; if not alongside the SDL file\n   * itself.\n   * @param {\n   *   function(\n   *     existingResolver: ResolverProperty,\n   *     newResolver: ResolverProperty\n   *   ): ResolverProperty\n   * } [options.conflictResolver] - A function to resolve conflicts between\n   * existing and new resolvers.\n   * @param {string[]} [options.gqExts] - An array of extensions with a\n   * preceding period, that will match the SDL files in the supplied directory.\n   * This defaults to `['.graphql', '.gql', '.sdl', '.typedef']`\n   * @param [string[]] [options.jsExts] - An array of extensions with a\n   * preceding period, that will match the resolver JavaScript files. This\n   * defaults to `['.js', '.cjs', '.mjs']`\n   * @param {string|string[]} [options.resolversRoots] - The root directory, or\n   * directories, where resolver files should exist. If this value is falsy,\n   * the expected root is in the same directory as the SDL file.\n   * @param {string} [options.projectRoot] - The root directory of the project,\n   * relative to the nearest package.json if no value is supplied.\n   * @returns {Schemata?} an instance of Schemata, optionally made executable\n   * if adjacent or otherwise specified .js/.ts/.cjs/.mjs files were located\n   */\n  static async buildFromDir(\n    path,\n    options = {\n      conflictResolver(_, newResolver) { return newResolver.value },\n      gqExts: ['.graphql', '.gql', '.sdl', '.typedef'],\n      jsExts: ['.js', '.cjs', '.mjs'],\n      resolversRoots: undefined,\n      projectRoot: undefined,\n    },\n  ) {\n    const parseAndRemoveExtension = (path) => ({\n      // path.parse of fully resolved path string\n      ...pathParse(pathResolve(path)),\n\n      // remove any existing extension and clear base so pathFormat works\n      ...{ base: '', ext: '' }}\n    )\n\n    const isDirectory = async path => await asyncTryCatch(\n      async () => (await stat(path)).isDirectory(), false\n    )\n\n    const rePathDir = ((await isDirectory(pathResolve(path)))\n      ? pathResolve(path)\n      : pathResolve(parseAndRemoveExtension(path).dir)\n    )\n    const rePath = rePathDir\n    const gqExts = options?.gqExts ?? ['.graphql', '.gql', '.sdl', '.typedef']\n    const jsExts = options?.jsExts ?? ['.js', '.cjs', '.mjs', '.ts']\n\n    const uniqueStems = [\n      // Ensure unique file paths (sans extension)\n      ...new Set(await (\n        [...await readdir(rePath, { recursive:true })].reduce(\n          async (asyncPrevious, current) => {\n            const previous = await asyncPrevious;\n            const fullPath = pathResolve(pathJoin(rePath, current));\n            const isDir = await isDirectory(fullPath)\n            console.log(previous, fullPath, isDir)\n\n            try {\n              if (!isDir) {\n                previous.push(pathFormat(parseAndRemoveExtension(fullPath)))\n              }\n            }\n            catch (skip) { }\n\n            return previous\n          }, []\n        )\n      ))\n    ]\n\n    const conflictResolver = options?.conflictResolver ?? ((_,n) => n.value)\n    const projectRoot = options?.projectRoot ?? await guessProjectRoot()\n    const resolverRoots = options?.resolverRoots\n      ? (Array.isArray(options?.resolverRoots)\n        ? options?.resolverRoots\n        : [String(options?.resolverRoots)]\n      )\n      : [rePath]\n\n\n    const paths = {\n      sdl: [],\n      resolver: [],\n      unknown: [],\n      hasValues: false,\n    }\n\n    console.log({uniqueStems, projectRoot, resolverRoots})\n\n    for (const resolverRoot of resolverRoots) {\n      for (const stem of uniqueStems) {\n        const stemParsed = parseAndRemoveExtension(stem)\n        const rootRelative = resolverRoot.includes(projectRoot)\n          ? pathResolve(pathJoin(pathRelative(projectRoot, resolverRoot), stemParsed.name))\n          : pathResolve(pathJoin(resolverRoot, stemParsed.name))\n        const results = await resolvedPaths(rootRelative, [...gqExts, ...jsExts])\n        console.log({ rootRelative, results })\n\n        if (results.hasValues) {\n          paths.sdl = paths.sdl.concat(results.sdl)\n          paths.resolver = paths.resolver.concat(results.resolver)\n          paths.unknown = paths.unknown.concat(results.unknown)\n          paths.hasValues = paths.hasValues || results.hasValues\n        }\n      }\n    }\n\n    console.log({ paths })\n    const { schemata } = await importResolvedGraphQL(paths, { conflictResolver })\n\n    return schemata\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get ALL() {\n    return ALL\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available type within the schema.\n   *\n   * @type {number}\n   */\n  static get TYPES() {\n    return TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available interface within the schema.\n   *\n   * @type {number}\n   */\n  static get INTERFACES() {\n    return INTERFACES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available enum within the schema.\n   *\n   * @type {number}\n   */\n  static get ENUMS() {\n    return ENUMS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available union within the schema.\n   *\n   * @type {number}\n   */\n  static get UNIONS() {\n    return UNIONS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available scalar within the schema.\n   *\n   * @type {number}\n   */\n  static get SCALARS() {\n    return SCALARS\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available root type; Query, Mutation and Subscription\n   *\n   * @type {number}\n   */\n  static get ROOT_TYPES() {\n    return ROOT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you wish to iterate\n   * over every available GraphQLInputObjectType within the schema.\n   *\n   * @type {number}\n   */\n  static get INPUT_TYPES() {\n    return INPUT_TYPES\n  }\n\n  /**\n   * Constant used with `forEachOf()` that signifies you also wish to\n   * iterate over the meta types. These are denoted by a leading double\n   * underscore.\n   *\n   * Can be OR'ed together such as `Schemata.TYPES | Schemata.HIDDEN`\n   *\n   * @type {number}\n   */\n  static get HIDDEN() {\n    return HIDDEN\n  }\n\n  /**\n     * Returns a GraphQLSchema object. Note this will fail and throw an error\n     * if there is not at least one Query, Subscription or Mutation type defined.\n     * If there is no stored schema, and there are resolvers, an executable\n     * schema is returned instead.\n     *\n     * @return {GraphQLSchema} an instance of GraphQLSchema if valid SDL\n     */\n  #generateSchema() {\n    const Class = this.constructor\n    const resolvers = this.resolvers\n    let schema\n\n    // If we have a generated schema already and this instance has a\n    // resolvers object that is not falsey, check to see if the object\n    // has the executable schema flag set or not. If so, simply return\n    // the pre-existing object rather than create a new one.\n    if (this[MAP].get(wmkSchema)) {\n      schema = this[MAP].get(wmkSchema)\n\n      if (resolvers) {\n        // check for the executable schema flag\n        if (schema?.[EXE]) {\n          return schema\n        }\n      }\n      else if (schema) {\n        return schema\n      }\n    }\n\n    // Attempt to generate a schema using the SDL for this instance. Throw\n    // an error if the SDL is insufficient to generate a GraphQLSchema object\n    try {\n      debug_log('[get .schema] creating schema from SDL')\n      this[MAP].set(wmkSchema, (schema = Class.buildSchema(this.sdl, true)))\n\n      // Now try to handle and ObjectTypeExtensions\n      let ast = this.ast\n\n      ast.definitions = [].concat(ast.definitions.filter(\n        i => i.kind == 'ObjectTypeExtension'\n      ))\n\n      try {\n        this[MAP].set(wmkSchema, (schema = extendSchema(schema, ast)))\n      }\n      catch (error) {\n        debug_log('[get .schema] failed to handle extended types')\n        debug_trace('[get .schema] ERROR!', error)\n      }\n\n    }\n    catch (error) {\n      debug_log('[get .schema] failed to create schema')\n      debug_trace('[get .schema] ERROR!', error)\n      return null\n    }\n\n    // Only iterate over the fields if there are resolvers set\n    if (resolvers) {\n      forEachField(\n        schema,\n        (\n          type,\n          typeName,\n          typeDirectives,\n          field,\n          fieldName,\n          fieldArgs,\n          fieldDirectives,\n          schema,\n          context\n        ) => {\n          if (isRootType(type) && resolvers[fieldName]) {\n            field.resolve = resolvers[fieldName]\n            field.astNode.resolve = resolvers[fieldName]\n          }\n\n          if (resolvers?.[typeName]?.[fieldName]) {\n            field.resolve = resolvers[typeName][fieldName]\n            field.astNode.resolve = resolvers[typeName][fieldName]\n          }\n        }\n      )\n\n      this.resolverInfo.forEach(resolverInfo => {\n        resolverInfo.applyTo(schema)\n      })\n\n      schema[EXE] = true\n    }\n\n    // Set the generated schema in the weak map using the weak map key\n    this[MAP].set(wmkSchema, schema)\n\n    return schema\n  }\n}\n\n/**\n * Given an type, determine if the type is a root type; i.e. one of Query,\n * Mutation or Subscription as defined in the `graphql` library.\n *\n * @param  {unknown} t a GraphQL AST or object type denoting a schema type\n * @return {Boolean} true if the type supplied is a root type; false otherwise\n */\nexport const isRootType = t => {\n  if (t === undefined || t === null || !t) {\n    return false\n  }\n\n  return (\n    t instanceof GraphQLObjectType &&\n    ['Query', 'Mutation', 'Subscription'].includes(t.name)\n  )\n}\n\n/**\n * Loops over the `resolverInjectors` in the supplied config object and\n * lets each supplied function have a pass to inspect or modify the parameters\n * that will be used to bind future resolver functions.\n *\n * @param {MergeOptionsConfig} config a config object with an array of\n * `ResolverArgsTransformer` functions\n * @param {ResolverArgs} args an object with `source`, `args`, `context`\n * and `info`\n * @return {ResolverArgs} a resulting object with `source`, `args`,\n * `context` and `info`\n */\nexport function runInjectors(config, resolverArgs) {\n  let args: ResolverArgs\n\n  if (!Array.isArray(config.resolverInjectors)) {\n    config.resolverInjectors = [config.resolverInjectors]\n  }\n\n  for (let injector of config.resolverInjectors) {\n    args = injector(resolverArgs)\n  }\n\n  return args\n}\n\n/**\n * The merge options config takes the arguments passed into a given `resolve()`\n * function, allowing the implementor to modify the values before passing them\n * back out.\n *\n * This function takes a schema to inject into the info object, or fourth\n * parameter, passed to any resolver. Any `extraConfig` object added in will\n * have its resolverInjectors added to the list to be processed.\n *\n * @param {GraphQLSchema} schema the GraphQLSchema object being inserted\n * @param {MergeOptionsConfig} extraConfig an optional extraConfig option to\n * merge with the resulting output\n * @return {MergeOptionsConfig} a MergeOptionsConfig object that contains at\n * least a single `ResolverArgsTransformer` which injects the supplied `schema`\n * into the `info` object.\n */\nexport function SchemaInjectorConfig(schema, extraConfig) {\n  let baseConfig = {\n    resolverInjectors: [\n      function __schema_injector__({ source, args, context, info }) {\n        info.schema = schema || info.schema\n        return { source, args, context, info }\n      },\n    ],\n  }\n\n  if (extraConfig) {\n    if (extraConfig.resolverInjectors) {\n      if (!Array.isArray(extraConfig.resolverInjectors)) {\n        baseConfig.resolverInjectors.push(extraConfig.resolverInjectors)\n      }\n      else {\n        baseConfig.resolverInjectors = baseConfig.resolverInjectors.concat(\n          extraConfig.resolverInjectors\n        )\n      }\n    }\n  }\n\n  return baseConfig\n}\n\n/**\n * Walk the supplied GraphQLSchema instance and retrieve the resolvers stored\n * on it. These values are then returned with a [typeName][fieldName] pathing\n *\n * @param {GraphQLSchema} schema an instance of GraphQLSchema\n * @return {ResolverMap?} an object containing a mapping of typeName.fieldName\n * that links to the resolve() function it is associated within the supplied\n * schema\n */\nexport function stripResolversFromSchema(schema) {\n  let resolvers = {}\n\n  if (!schema) {\n    return null\n  }\n\n  forEachField(\n    schema,\n    (\n      type,\n      typeName,\n      typeDirectives,\n      field,\n      fieldName,\n      fieldArgs,\n      fieldDirectives,\n      _schema,\n      context\n    ) => {\n      if (field.resolve) {\n        resolvers[typeName] = resolvers[typeName] || {}\n        resolvers[typeName][fieldName] = resolvers[typeName][fieldName] || {}\n        resolvers[typeName][fieldName] = field.resolve\n      }\n    }\n  )\n\n  return resolvers\n}\n\n/** @type {Symbol} a unique symbol used as a key to all instance sdl strings */\nexport const TYPEDEFS_KEY = Symbol('internal-typedefs-key')\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const GRAPHIQL_FLAG = Symbol.for('internal-graphiql-key')\n\n/** @type {Symbol} a constant symbol used as a key to a flag for express-gql */\nexport const SCHEMA_DIRECTIVES = Symbol.for('internal-directives-key')\n\n/** @type {Symbol} a unique symbol used as a key to all instance `WeakMap`s */\nexport const MAP = Symbol('internal-weak-map-key')\n\n/** @type {Symbol} a key used to store the __executable__ flag on a schema */\nexport const EXE = Symbol('executable-schema')\n\n/** @type {Object} a key used to store a resolver object in a WeakMap */\nconst wmkResolvers = Object(Symbol('GraphQL Resolvers storage key'))\n\n/** @type {Object} a key used to store an internal schema in a WeakMap */\nconst wmkSchema = Object(Symbol('GraphQLSchema storage key'))\n\n/**\n * This is a `Symbol` key to a `WeakSet` of `ExtendedResolverMap` instances,\n * each of which have at least three properties:\n *\n *  - schema\n *  - sdl\n *  - resolvers\n *\n * One of these are created and added to the set whenever a mergeSchema is\n * performed. On each subsequent mergeSDL/Schema a new instance is added such\n * that new versions exist to be wrapped anew\n *\n * @type {[type]}\n */\nconst wmkPreboundResolvers = Object(Symbol('Resolvers pre-merge-wrapped'))\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {FieldNode} leftField The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {FieldNode} rightField the field cause the conflict\n *\n * @return {FieldNode} the field that should be used after resolution\n */\nexport function DefaultFieldMergeResolver(\n  leftType,\n  leftField,\n  rightType,\n  rightField\n) {\n  return rightField\n}\n\n/**\n * The default directive resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultDirectiveMergeResolver(\n  leftType,\n  leftDirective,\n  rightType,\n  rightDirective,\n) {\n  return rightDirective\n}\n\n/**\n * The default field resolver blindly takes returns the right field. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {DirectiveNode} leftDirective The field causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {DirectiveNode} rightDirective the field cause the conflict\n *\n * @return {DirectiveNode} the directive that should be used after resolution\n */\nexport function DefaultEnumMergeResolver(\n  leftType,\n  leftValue,\n  rightType,\n  rightValue\n) {\n  return rightValue\n}\n\n/**\n * The default union resolver blindly takes returns the right type. This\n * resolver is used when one is not specified.\n *\n * @param {ASTNode} leftType The matching left type indicating conflict\n * @param {NamedTypeNode} leftUnion The named node causing the conflict\n * @param {ASTNode} rightType The matching right type indicating conflict\n * @param {NamedTypeNode} rightUnion the named node cause the conflict\n *\n * @return {NamedTypeNode} the directive that should be used after resolution\n */\nexport function DefaultUnionMergeResolver(\n  leftType,\n  leftUnion,\n  rightType,\n  rightUnion\n) {\n  return rightUnion\n}\n\n/**\n * The default scalar merge resolver returns the right config when there is\n * one, otherwise the left one or null will be the default result. This is\n * slightly different behavior since resolvers for scalars are not always\n * available.\n *\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport function DefaultScalarMergeResolver(\n  leftScalar,\n  leftConfig,\n  rightScalar,\n  rightConfig\n) {\n  return (rightConfig || leftConfig) ?? null\n}\n\n/**\n * In order to facilitate merging, there needs to be some contingency plan\n * for what to do when conflicts arise. This object specifies one of each\n * type of resolver. Each simply takes the right-hand value.\n *\n * @type {Object}\n */\nexport const DefaultConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver: DefaultFieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver: DefaultDirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver: DefaultEnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver: DefaultUnionMergeResolver,\n\n  /** A handler for resolving scalar configs in custom scalars */\n  scalarMergeResolver: DefaultScalarMergeResolver,\n}\n\n/**\n * A `MergeOptionsConfig` object with an empty array of\n * `ResolverArgsTransformer` instances\n *\n * @type {MergeOptionsConfig}\n */\nexport const DefaultMergeOptions = {\n  conflictResolvers: DefaultConflictResolvers,\n  resolverInjectors: [],\n  injectMergedSchema: true,\n  createMissingResolvers: false,\n}\n\nconst subTypeResolverMap = new Map()\nsubTypeResolverMap.set('fields', 'fieldMergeResolver')\nsubTypeResolverMap.set('directives', 'directiveMergeResolver')\nsubTypeResolverMap.set('values', 'enumValueMergeResolver')\nsubTypeResolverMap.set('types', 'typeValueMergeResolver')\nsubTypeResolverMap.set('scalars', 'scalarMergeResolver')\n\n/**\n * Compares and combines a subset of ASTNode fields. Designed to work on all\n * the various types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction combineTypeAndSubType(\n  subTypeName,\n  lType,\n  rType,\n  conflictResolvers = DefaultConflictResolvers\n) {\n  if (rType[subTypeName]) {\n    for (let rSubType of rType[subTypeName]) {\n      let lSubType = lType[subTypeName].find(\n        f => f.name.value == rSubType.name.value\n      )\n\n      if (!lSubType) {\n        lType[subTypeName].push(rSubType)\n        continue\n      }\n\n      let resolver = subTypeResolverMap.get(subTypeName) || 'fieldMergeResolver'\n      let resultingSubType = conflictResolvers[resolver](\n        lType,\n        lSubType,\n        rType,\n        rSubType\n      )\n      let index = lType.fields.indexOf(lSubType)\n\n      lType[subTypeName].splice(index, 1, resultingSubType)\n    }\n  }\n}\n\n/**\n * Compares a subset of ASTNode fields. Designed to work on all the various\n * types that might have a merge conflict.\n *\n * @param {string} subTypeName the name of the field type; one of the following\n * values: 'fields', 'directives', 'values', 'types'\n * @param {ASTNode} lType the lefthand type containing the subtype to compare\n * @param {ASTNode} lSubType the lefthand subtype; fields, directive, value or\n * named union type\n * @param {ASTNode} rType the righthand type containing the subtype to compare\n * @param {ASTNode} rSubType the righthand subtype; fields, directive, value or\n * named union type\n */\nfunction pareTypeAndSubType(subTypeName, lType, rType, resolvers = {}) {\n  for (let rSubType of rType[subTypeName]) {\n    let lSubType = lType[subTypeName].find(\n      f => f.name.value == rSubType.name.value\n    )\n\n    if (!lSubType) {\n      continue\n    }\n\n    let index = lType.fields.indexOf(lSubType)\n    lType[subTypeName].splice(index, 1)\n\n    if (resolvers?.[lType.name.value]?.[lSubType.name.value]) {\n      delete resolvers[lType.name.value][lSubType.name.value]\n    }\n    else if (resolvers[lSubType.name.value]) {\n      delete resolvers[lSubType.name.value]\n    }\n  }\n}\n\n/**\n * Small function that sorts through the typeDefs value supplied which can be\n * any one of a Schemata instance, GraphQLSchema instance, Source instance or a\n * string.\n *\n * @param {SchemaSource} typeDefs an instance of Schemata, a string of SDL,\n * a Source instance of SDL, a GraphQLSchema or ASTNode that can be printed\n * as an SDL string\n * @return {string} a string representing the thing supplied as typeDefs\n */\nexport function normalizeSource(typeDefs, wrap = false) {\n  if (!typeDefs) {\n    throw new Error(inline`\n      normalizeSource(typeDefs): typeDefs was invalid when passed to the\n      function \\`normalizeSource\\`. Please check your code and try again.\n\n      (received: ${typeDefs})\n    `)\n  }\n\n  if (typeDefs instanceof Schemata && typeDefs.valid && wrap) {\n    return typeDefs\n  }\n\n  let source = (\n    typeDefs.body ||\n    typeDefs.sdl ||\n    (typeof typeDefs === 'string' && typeDefs) ||\n    (typeof typeDefs === 'object' && Schemata.print(typeDefs)) ||\n    (typeDefs instanceof GraphQLSchema\n      ? printSchema(typeDefs)\n      : typeDefs.toString())\n  ).toString().trim()\n\n  return wrap ? Schemata.from(source) : source\n}\n\nexport default Schemata\n"],"mappings":"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CAACD,SAAS,CAACpH,EAAE,EAAEgG,OAAO,EAAE6B,gBAAK,EAAER,cAAc,CAAC;EAC3D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACES,gBAAgBA,CAAC9H,EAAE,EAAEgG,OAAO,EAAEqB,cAAc,GAAG,IAAI,EAAE;IACnD,OAAO,IAAI,CAACD,SAAS,CAACpH,EAAE,EAAEgG,OAAO,EAAE+B,qBAAU,EAAEV,cAAc,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEW,aAAaA,CAAChI,EAAE,EAAEgG,OAAO,EAAEqB,cAAc,GAAG,IAAI,EAAE;IAChD,OAAO,IAAI,CAACD,SAAS,CAACpH,EAAE,EAAEgG,OAAO,EAAEiC,kBAAO,EAAEZ,cAAc,CAAC;EAC7D;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEa,eAAeA,CAAClI,EAAE,EAAEgG,OAAO,EAAEqB,cAAc,GAAG,IAAI,EAAE;IAClD,OAAO,IAAI,CAACD,SAAS,CAACpH,EAAE,EAAEgG,OAAO,EAAEmC,qBAAU,EAAEd,cAAc,CAAC;EAChE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE1B,YAAYA,CAAC3F,EAAE,EAAEgG,OAAO,EAAEtG,KAAK,GAAG0I,cAAG,EAAEf,cAAc,GAAG,IAAI,EAAiB;IAC3E,IAAI1I,MAAM,GAAG0I,cAAc,IAAI,IAAI,CAAC1I,MAAM;IAE1C,IAAAgH,uBAAY,EAAChH,MAAM,EAAEqB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AAM,CAAC,2BAA2B,CAAC,CAAC;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMJ,oBAAoB,GAAGsB,MAAM,CAAClB,MAAM,CAAC,6BAA6B,CAAC,CAAC;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoQ,yBAAyBA,CACvCC,QAAQ,EACRC,SAAS,EACTC,SAAS,EACTC,UAAU,EACV;EACA,OAAOA,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,6BAA6BA,CAC3CJ,QAAQ,EACRK,aAAa,EACbH,SAAS,EACTI,cAAc,EACd;EACA,OAAOA,cAAc;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,wBAAwBA,CACtCP,QAAQ,EACRQ,SAAS,EACTN,SAAS,EACTO,UAAU,EACV;EACA,OAAOA,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,yBAAyBA,CACvCV,QAAQ,EACRW,SAAS,EACTT,SAAS,EACTU,UAAU,EACV;EACA,OAAOA,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,0BAA0BA,CACxCC,UAAU,EACVC,UAAU,EACVC,WAAW,EACXC,WAAW,EACX;EACA,OAAO,CAACA,WAAW,IAAIF,UAAU,KAAK,IAAI;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMvM,wBAAwB,GAAA2K,OAAA,CAAA3K,wBAAA,GAAG;EACtC;EACA0M,kBAAkB,EAAEnB,yBAAyB;EAE7C;EACAoB,sBAAsB,EAAEf,6BAA6B;EAErD;EACAgB,sBAAsB,EAAEb,wBAAwB;EAEhD;EACAc,sBAAsB,EAAEX,yBAAy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","ignoreList":[]}