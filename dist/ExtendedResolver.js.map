{"version":3,"file":"ExtendedResolver.js","names":["_graphql","require","_Schemata","_errors","original","Symbol","listing","patcher","isFn","o","test","Object","prototype","toString","call","ExtendedResolver","Function","constructor","resolver","defaultFieldResolver","Array","from","Proxy","handler","order","value","resultPatcher","originalIndex","indexOf","prepend","preresolver","index","splice","append","postresolver","length","push","strings","fn","name","repeat","join","show","console","log","toStringTag","newResolver","wrap","prepends","appends","isArray","forEach","SchemaInjector","originalResolver","newSchema","undefined","source","args","context","info","arguments","schema","rootValue","stripResolversFromSchema","apply","target","thisArg","myArgs","results","result","concat","error","WrappedResolverExecutionError","assign","ResolverResultsPatcherError","exports"],"sources":["../src/ExtendedResolver.js"],"sourcesContent":["// @ts-check\n\nimport { defaultFieldResolver } from 'graphql'\nimport { stripResolversFromSchema } from './Schemata'\nimport {\n  WrappedResolverExecutionError,\n  ResolverResultsPatcherError\n} from './errors'\n\nimport type { ResolverResultsPatcher } from './types'\nimport {\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLSchema,\n} from 'graphql'\n\nconst original = Symbol('Original Resolver')\nconst listing = Symbol('List of Resolvers')\nconst patcher = Symbol('Resolver Result Patcher')\n\n// $FlowIgnore[method-unbinding]\nconst isFn = (o: any) => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * Higher order, or wrapped, GraphQL field resolvers are a technique that\n * is becoming increasingly common these days. This class attempts to wrap\n * that in such a manner that it allows a bit of extensibility.\n *\n * @extends Function\n */\nexport class ExtendedResolver extends Function {\n  /**\n   * Creates a new instance of `ExtendedResolver` for use with GraphQL. If\n   * the supplied resolver is already an instance of `ExtendedResolver`, its\n   * internal nested resolvers are copied, alongside the rest of the custom\n   * properties that make up an instance of `ExtendedResolver`\n   *\n   * @since 1.9\n   *\n   * @param {GraphQLFieldResolver} resolver a normal GraphQLFieldResolver\n   * function. By default, the `defaultFieldResolver` is used if no other\n   * value is supplied\n   */\n  constructor(resolver: GraphQLFieldResolver = defaultFieldResolver) {\n    super()\n\n    if (resolver instanceof ExtendedResolver) {\n      this[listing] = Array.from(resolver[listing])\n      this[original] = resolver[original]\n      this[patcher] = resolver[patcher]\n    }\n    else {\n      this[listing] = [resolver]\n      this[original] = resolver\n      this[patcher] = null\n    }\n\n    return new Proxy(this, ExtendedResolver.handler)\n  }\n\n  // Properties\n\n  /**\n   * Returns a handle to the internal array of ordered resolver\n   * functions, should indepth modification be necessary.\n   *\n   * @return  {Array<GraphQLFieldResolver>} the internal list of\n   * resolvers to execute in order as though it were a single resolver\n   */\n  get order(): Array<GraphQLFieldResolver> {\n    return this[listing]\n  }\n\n  /**\n   * An accessor that writes a new resolver to the internal list of\n   * resolvers that combine into a single resolver for inclusion elsewhere.\n   *\n   * TODO come up with some ideas on how to handle setting of this list\n   * when the list no longer contains the original. Throw error? Log? Add it\n   * to the end? Allow all in some configurable manner?\n   *\n   * @param  {Array<GraphQLFieldResolver>} value the new array\n   */\n  set order(value: Array<GraphQLFieldResolver>) {\n    this[listing] = value\n  }\n\n  /**\n   * Retrieve the internal result value patcher function. By default, this\n   * value is null and nonexistent. When present, it is a function that will\n   * be called after all internal resolvers have done their work but before\n   * those results are returned to the calling function.\n   *\n   * The function takes as its only parameter the culmination of results from\n   * the internal resolvers work. Whatever is returned from this function is\n   * returned as the final results.\n   *\n   * @return {ResolverResultsPatcher} a function or null\n   */\n  get resultPatcher(): ResolverResultsPatcher {\n    return this[patcher]\n  }\n\n  /**\n   * Sets the internal patcher function.\n   *\n   * @see resultPatcher getter above\n   * @param {ResolverResultsPatcher} value a new patcher function\n   */\n  set resultPatcher(value: ResolverResultsPatcher) {\n    this[patcher] = value\n  }\n\n  /**\n   * A getter that retrieves the original resolver from within the\n   * `ExtendedResolver` instance.\n   *\n   * @method original\n   * @readonly\n   *\n   * @return {GraphQLFieldResolver} the originally wrapped field resolver\n   */\n  get original(): GraphQLFieldResolver {\n    return this[original]\n  }\n\n  /**\n   * The dynamic index of the original resolver inside the internal listing.\n   * As prepended and appended resolvers are added to the `ExtendedResolver`,\n   * this value will change.\n   *\n   * @method originalIndex\n   * @readonly\n   *\n   * @return {number} the numeric index of the original resolver within the\n   * internal listing. -1 indicates that the original resolver is missing\n   * which, in and of itself, indicates an invalid state.\n   */\n  get originalIndex(): number {\n    return this[listing].indexOf(this[original])\n  }\n\n  // Methods\n\n  /**\n   * Guaranteed to insert the supplied field resolver after any other prepended\n   * field resolvers and before the original internal field resolver.\n   *\n   * @param {GraphQLFieldResolver} preresolver a field resolver to run before\n   * the original field resolver executes.\n   */\n  prepend(preresolver: GraphQLFieldResolver) {\n    if (preresolver && isFn(preresolver)) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index : 0\n\n      this[listing].splice(index, 0, preresolver)\n    }\n  }\n\n  /**\n   * Inserts the supplied field resolver function after the original resolver\n   * but before any previously added post resolvers. If you simply wish to\n   * push another entry to the list, use `.push`\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original but before other postresolvers previously added.\n   */\n  append(postresolver: GraphQLFieldResolver) {\n    if (postresolver && isFn(postresolver)) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index + 1 : this[listing].length\n\n      this[listing].splice(index, 0, postresolver)\n    }\n  }\n\n  /**\n   * Simply adds a field resolver to the end of the list rather than trying\n   * to put it as close to the original resolver as possible.\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original\n   */\n  push(postresolver: GraphQLFieldResolver) {\n    if (postresolver && isFn(postresolver)) {\n      this[listing].push(postresolver)\n    }\n  }\n\n  /**\n   * The `.toString()` functionality of the ExtendedResolver dutifily lists the\n   * source of each function to be executed in order.\n   *\n   * @method toString\n   *\n   * @return {string} a combined toString() functionality for each item in\n   * order\n   */\n  toString(): string {\n    let strings: Array<string> = []\n\n    for (let fn of this.order) {\n      strings.push(`Function: ${fn.name}`)\n      strings.push(\n        `---------${'-'.repeat(fn.name.length ? fn.name.length + 1 : 0)}`\n      )\n      strings.push(fn.toString())\n      strings.push('')\n    }\n\n    return strings.join('\\n')\n  }\n\n  /**\n   * After having to repeatedly console.log the toString output, this function\n   * now does that easier for me so I don't end up with carpal tunnel earlier\n   * than necessary.\n   *\n   * @method show\n   */\n  show(): void {\n    console.log(this.toString())\n  }\n\n  // Symbols\n\n  /**\n   * Ensure that when inspected with Object.prototype.toString.call/apply\n   * that instances of ExtendedResolver return `'[object ExtendedResolver]'`\n   *\n   * @type {Symbol}\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  // Statics\n\n  /**\n   * Shorthand static initializer that allows the ExtendedResolver class to\n   * be instantiated using `ExtendedResolver.from()` rather than the normal\n   * `new ExtendedResolver()`. Additionally it offers a way to set a result\n   * patcher after initialization has occurred\n   *\n   * @param {GraphQLFieldResolver} resolver the resolver to initialize the\n   * class instance with.\n   * @param {ResolverResultsPatcher} patcher an optional function matching the\n   * `ResolverResultsPatcher` signature to set to the new instance after it is\n   * created.\n   * @return {ExtendedResolver} a newly minted instance of the class\n   * `ExtendedResolver`\n   */\n  static from(\n    resolver: GraphQLFieldResolver,\n    patcher?: ResolverResultsPatcher\n  ): ExtendedResolver {\n    let newResolver = new ExtendedResolver(resolver)\n\n    if (patcher) {\n      newResolver.resultPatcher = patcher\n    }\n\n    return newResolver\n  }\n\n  /**\n   * Similar to the `.from` static initializer, the `.wrap` initializer\n   * takes an original field resolver, an optional patcher as in `.from`\n   * as well as an array of `prepends` and `appends` field resolvers which\n   * will be slotted in the appropriate locations.\n   *\n   * @param  {GraphQLFieldResolver} original a field resolver function that\n   * is to be wrapped as the basis for the resulting `ExtendedResolver`\n   * @param {ResolverResultsPatcher} patcher an optional function that allows\n   * the user to patch the results of the total field resolver culmination\n   * before allowing the calling code to see them.\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} prepends either\n   * a single GraphQLFieldResolver or an array of them to prepend before the\n   * original field resolver executes\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} appends either\n   * a single GraphQLFieldResolver or an array of them to prepend after the\n   * original field resolver executes\n   * @return {[type]}          [description]\n   */\n  static wrap(\n    original: GraphQLFieldResolver,\n    prepends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = [],\n    appends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = [],\n    patcher?: ResolverResultsPatcher = null\n  ) {\n    let resolver = ExtendedResolver.from(original)\n\n    if (patcher && isFn(patcher)) {\n      resolver.resultPatcher = patcher\n    }\n\n    if (prepends) {\n      if (!Array.isArray(prepends)) {\n        prepends = [prepends]\n      }\n\n      if (prepends.length) {\n        prepends.forEach(fn => resolver.prepend(fn))\n      }\n    }\n\n    if (appends) {\n      if (!Array.isArray(appends)) {\n        appends = [appends]\n      }\n\n      if (appends.length) {\n        appends.forEach(fn => resolver.append(fn))\n      }\n    }\n\n    return resolver\n  }\n\n  /**\n   * In the process of schema stitching, it is possible and likely that\n   * a given schema has been extended or enlarged during the merging process\n   * with another schema. Neither of the old schemas have any idea of the\n   * layout of the newer, grander, schema. Therefore it is necessary to\n   * inject the new GraphQLSchema as part of the info parameters received\n   * by the resolver for both sides of the stitched schema in order to\n   * prevent errors.\n   *\n   * This static method takes the original resolver, wraps it with a\n   * prepended resolver that injects the new schema; also supplied as the\n   * second parameter. The result is a newly minted `ExtendedResolver` that\n   * should do the job in question.\n   *\n   * @param {GraphQLFieldResolver} originalResolver the original resolver todo\n   * wrap.\n   * @param {GraphQLSchema} newSchema the new, grander, schema with all fields\n   * @param {ResolverResultsPatcher} patcher a function that will allow you to\n   * modify the\n   */\n  static SchemaInjector(\n    originalResolver: GraphQLFieldResolver,\n    newSchema: GraphQLSchema,\n    patcher?: ResolverResultsPatcher = undefined\n  ) {\n    return ExtendedResolver.wrap(\n      originalResolver,\n      [\n        function SchemaInjector(\n          source: any,\n          args: any,\n          context: { [argument: string]: any },\n          info: GraphQLResolveInfo\n        ) {\n          if (arguments.length === 3 && context.schema) {\n            context.schema = newSchema\n            context.rootValue = stripResolversFromSchema(newSchema)\n          }\n          else if (arguments.length === 4 && info.schema) {\n            info.schema = newSchema\n            info.rootValue = stripResolversFromSchema(newSchema)\n          }\n        },\n      ],\n      [ ],\n      patcher\n    )\n  }\n\n  /**\n   * All instances of `ExtendedResolver` are Proxies to the instantiated\n   * class with a specially defined `.apply` handler to make their custom\n   * execution flow work.\n   *\n   * @type {Object}\n   */\n  static get handler(): Object {\n    return {\n      /**\n       * Reduce the results of each resolver in the list, including\n       * the original resolver. Calling each in order with the same\n       * parameters and returning the coalesced results\n       *\n       * @param {mixed} target this should always be the object context\n       * @param {mixed} thisArg the `this` object for the context of the\n       * function calls\n       * @param {Array<mixed>} args the arguments object as seen in all\n       * graphql resolvers\n       * @return {mixed} either null or some value as would have been returned\n       * from the call of a graphql field resolver\n       */\n      async apply(target, thisArg, args) {\n        // Ensure we have arguments as an array so we can concat results in\n        // each pass of the reduction process\n        let myArgs = Array.isArray(args)\n          ? args\n          : Array.from((args && args) || [])\n\n\n        let results = {}\n        let result\n\n        for (let fn of target[listing]) {\n          try {\n            result = await fn.apply(\n              thisArg || target,\n              myArgs.concat(results)\n            )\n          }\n          catch (error) {\n            throw new WrappedResolverExecutionError(\n              error,\n              this,\n              target[listing].indexOf(fn),\n              myArgs.concat(results),\n              thisArg || target\n            );\n          }\n\n          if (\n            results &&\n            results instanceof Object &&\n            result &&\n            result instanceof Object\n          ) {\n            Object.assign(results, result)\n          }\n          else {\n            results = result\n          }\n        }\n\n        if (target[patcher] && target[patcher] instanceof Function) {\n          try {\n            results = await target[patcher].call(thisArg || target, results)\n          }\n          catch (error) {\n            throw new ResolverResultsPatcherError(\n              error,\n              target[patcher],\n              (thisArg || target),\n              results\n            )\n          }\n        }\n\n        return results\n      },\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}