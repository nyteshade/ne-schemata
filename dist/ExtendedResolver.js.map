{"version":3,"sources":["../src/ExtendedResolver.js"],"names":["original","Symbol","listing","patcher","isFn","o","test","Object","prototype","toString","call","ExtendedResolver","Function","constructor","resolver","defaultFieldResolver","Array","from","Proxy","handler","order","value","resultPatcher","originalIndex","indexOf","prepend","preresolver","index","splice","append","postresolver","length","push","strings","fn","name","repeat","join","show","console","log","toStringTag","newResolver","wrap","prepends","appends","isArray","forEach","SchemaInjector","originalResolver","newSchema","undefined","source","args","context","info","arguments","schema","rootValue","apply","target","thisArg","myArgs","results","result","concat","error","WrappedResolverExecutionError","assign","ResolverResultsPatcherError"],"mappings":"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","file":"ExtendedResolver.js","sourceRoot":"src","sourcesContent":["import { defaultFieldResolver } from 'graphql'\nimport { stripResolversFromSchema } from './Schemata'\nimport {\n  WrappedResolverExecutionError,\n  ResolverResultsPatcherError\n} from './errors'\n\nimport type { ResolverResultsPatcher } from './types'\nimport type {\n  GraphQLFieldResolver,\n  GraphQLResolveInfo,\n  GraphQLSchema,\n} from 'graphql'\n\nconst original = Symbol('Original Resolver')\nconst listing = Symbol('List of Resolvers')\nconst patcher = Symbol('Resolver Result Patcher')\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * Higher order, or wrapped, GraphQL field resolvers are a technique that\n * is becoming increasingly common these days. This class attempts to wrap\n * that in such a manner that it allows a bit of extensibility.\n *\n * @extends Function\n */\nexport class ExtendedResolver extends Function {\n  /**\n   * Creates a new instance of `ExtendedResolver` for use with GraphQL. If\n   * the supplied resolver is already an instance of `ExtendedResolver`, its\n   * internal nested resolvers are copied, alongside the rest of the custom\n   * properties that make up an instance of `ExtendedResolver`\n   *\n   * @since 1.9\n   *\n   * @param {GraphQLFieldResolver} resolver a normal GraphQLFieldResolver\n   * function. By default, the `defaultFieldResolver` is used if no other\n   * value is supplied\n   */\n  constructor(resolver: GraphQLFieldResolver = defaultFieldResolver) {\n    super()\n\n    if (resolver instanceof ExtendedResolver) {\n      this[listing] = Array.from(resolver[listing])\n      this[original] = resolver[original]\n      this[patcher] = resolver[patcher]\n    }\n    else {\n      this[listing] = [resolver]\n      this[original] = resolver\n      this[patcher] = null\n    }\n\n    return new Proxy(this, ExtendedResolver.handler)\n  }\n\n  // Properties\n\n  /**\n   * Returns a handle to the internal array of ordered resolver\n   * functions, should indepth modification be necessary.\n   *\n   * @return  {Array<GraphQLFieldResolver>} the internal list of\n   * resolvers to execute in order as though it were a single resolver\n   */\n  get order(): Array<GraphQLFieldResolver> {\n    return this[listing]\n  }\n\n  /**\n   * An accessor that writes a new resolver to the internal list of\n   * resolvers that combine into a single resolver for inclusion elsewhere.\n   *\n   * TODO come up with some ideas on how to handle setting of this list\n   * when the list no longer contains the original. Throw error? Log? Add it\n   * to the end? Allow all in some configurable manner?\n   *\n   * @param  {Array<GraphQLFieldResolver>} value the new array\n   */\n  set order(value: Array<GraphQLFieldResolver>) {\n    this[listing] = value\n  }\n\n  /**\n   * Retrieve the internal result value patcher function. By default, this\n   * value is null and nonexistent. When present, it is a function that will\n   * be called after all internal resolvers have done their work but before\n   * those results are returned to the calling function.\n   *\n   * The function takes as its only parameter the culmination of results from\n   * the internal resolvers work. Whatever is returned from this function is\n   * returned as the final results.\n   *\n   * @return {ResolverResultsPatcher} a function or null\n   */\n  get resultPatcher(): ResolverResultsPatcher {\n    return this[patcher]\n  }\n\n  /**\n   * Sets the internal patcher function.\n   *\n   * @see resultPatcher getter above\n   * @param {ResolverResultsPatcher} value a new patcher function\n   */\n  set resultPatcher(value: ResolverResultsPatcher) {\n    this[patcher] = value\n  }\n\n  /**\n   * A getter that retrieves the original resolver from within the\n   * `ExtendedResolver` instance.\n   *\n   * @method original\n   * @readonly\n   *\n   * @return {GraphQLFieldResolver} the originally wrapped field resolver\n   */\n  get original(): GraphQLFieldResolver {\n    return this[original]\n  }\n\n  /**\n   * The dynamic index of the original resolver inside the internal listing.\n   * As prepended and appended resolvers are added to the `ExtendedResolver`,\n   * this value will change.\n   *\n   * @method originalIndex\n   * @readonly\n   *\n   * @return {number} the numeric index of the original resolver within the\n   * internal listing. -1 indicates that the original resolver is missing\n   * which, in and of itself, indicates an invalid state.\n   */\n  get originalIndex(): number {\n    return this[listing].indexOf(this[original])\n  }\n\n  // Methods\n\n  /**\n   * Guaranteed to insert the supplied field resolver after any other prepended\n   * field resolvers and before the original internal field resolver.\n   *\n   * @param {GraphQLFieldResolver} preresolver a field resolver to run before\n   * the original field resolver executes.\n   */\n  prepend(preresolver: GraphQLFieldResolver) {\n    if (preresolver && isFn(preresolver)) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index : 0\n\n      this[listing].splice(index, 0, preresolver)\n    }\n  }\n\n  /**\n   * Inserts the supplied field resolver function after the original resolver\n   * but before any previously added post resolvers. If you simply wish to\n   * push another entry to the list, use `.push`\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original but before other postresolvers previously added.\n   */\n  append(postresolver: GraphQLFieldResolver) {\n    if (postresolver && isFn(postresolver)) {\n      let index = this[listing].indexOf(this[original])\n\n      index = ~index ? index + 1 : this[listing].length\n\n      this[listing].splice(index, 0, postresolver)\n    }\n  }\n\n  /**\n   * Simply adds a field resolver to the end of the list rather than trying\n   * to put it as close to the original resolver as possible.\n   *\n   * @param {GraphQLFieldResolver} postresolver a field resolver that should\n   * run after the original\n   */\n  push(postresolver: GraphQLFieldResolver) {\n    if (postresolver && isFn(postresolver)) {\n      this[listing].push(postresolver)\n    }\n  }\n\n  /**\n   * The `.toString()` functionality of the ExtendedResolver dutifily lists the\n   * source of each function to be executed in order.\n   *\n   * @method toString\n   *\n   * @return {string} a combined toString() functionality for each item in\n   * order\n   */\n  toString(): string {\n    let strings: Array<string> = []\n\n    for (let fn of this.order) {\n      strings.push(`Function: ${fn.name}`)\n      strings.push(\n        `---------${'-'.repeat(fn.name.length ? fn.name.length + 1 : 0)}`\n      )\n      strings.push(fn.toString())\n      strings.push('')\n    }\n\n    return strings.join('\\n')\n  }\n\n  /**\n   * After having to repeatedly console.log the toString output, this function\n   * now does that easier for me so I don't end up with carpal tunnel earlier\n   * than necessary.\n   *\n   * @method show\n   */\n  show(): void {\n    console.log(this.toString())\n  }\n\n  // Symbols\n\n  /**\n   * Ensure that when inspected with Object.prototype.toString.call/apply\n   * that instances of ExtendedResolver return `'[object ExtendedResolver]'`\n   *\n   * @type {Symbol}\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n\n  // Statics\n\n  /**\n   * Shorthand static initializer that allows the ExtendedResolver class to\n   * be instantiated using `ExtendedResolver.from()` rather than the normal\n   * `new ExtendedResolver()`. Additionally it offers a way to set a result\n   * patcher after initialization has occurred\n   *\n   * @param {GraphQLFieldResolver} resolver the resolver to initialize the\n   * class instance with.\n   * @param {ResolverResultsPatcher} patcher an optional function matching the\n   * `ResolverResultsPatcher` signature to set to the new instance after it is\n   * created.\n   * @return {ExtendedResolver} a newly minted instance of the class\n   * `ExtendedResolver`\n   */\n  static from(\n    resolver: GraphQLFieldResolver,\n    patcher?: ResolverResultsPatcher\n  ): ExtendedResolver {\n    let newResolver = new ExtendedResolver(resolver)\n\n    if (patcher) {\n      newResolver.resultPatcher = patcher\n    }\n\n    return newResolver\n  }\n\n  /**\n   * Similar to the `.from` static initializer, the `.wrap` initializer\n   * takes an original field resolver, an optional patcher as in `.from`\n   * as well as an array of `prepends` and `appends` field resolvers which\n   * will be slotted in the appropriate locations.\n   *\n   * @param  {GraphQLFieldResolver} original a field resolver function that\n   * is to be wrapped as the basis for the resulting `ExtendedResolver`\n   * @param {ResolverResultsPatcher} patcher an optional function that allows\n   * the user to patch the results of the total field resolver culmination\n   * before allowing the calling code to see them.\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} prepends either\n   * a single GraphQLFieldResolver or an array of them to prepend before the\n   * original field resolver executes\n   * @param {GraphQLFieldResolver|Array<GraphQLFieldResolver>} appends either\n   * a single GraphQLFieldResolver or an array of them to prepend after the\n   * original field resolver executes\n   * @return {[type]}          [description]\n   */\n  static wrap(\n    original: GraphQLFieldResolver,\n    prepends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = [],\n    appends?: GraphQLFieldResolver | Array<GraphQLFieldResolver> = [],\n    patcher?: ResolverResultsPatcher = null\n  ) {\n    let resolver = ExtendedResolver.from(original)\n\n    if (patcher && isFn(patcher)) {\n      resolver.resultPatcher = patcher\n    }\n\n    if (prepends) {\n      if (!Array.isArray(prepends)) {\n        prepends = [prepends]\n      }\n\n      if (prepends.length) {\n        prepends.forEach(fn => resolver.prepend(fn))\n      }\n    }\n\n    if (appends) {\n      if (!Array.isArray(appends)) {\n        appends = [appends]\n      }\n\n      if (appends.length) {\n        appends.forEach(fn => resolver.append(fn))\n      }\n    }\n\n    return resolver\n  }\n\n  /**\n   * In the process of schema stitching, it is possible and likely that\n   * a given schema has been extended or enlarged during the merging process\n   * with another schema. Neither of the old schemas have any idea of the\n   * layout of the newer, grander, schema. Therefore it is necessary to\n   * inject the new GraphQLSchema as part of the info parameters received\n   * by the resolver for both sides of the stitched schema in order to\n   * prevent errors.\n   *\n   * This static method takes the original resolver, wraps it with a\n   * prepended resolver that injects the new schema; also supplied as the\n   * second parameter. The result is a newly minted `ExtendedResolver` that\n   * should do the job in question.\n   *\n   * @param {GraphQLFieldResolver} originalResolver the original resolver todo\n   * wrap.\n   * @param {GraphQLSchema} newSchema the new, grander, schema with all fields\n   * @param {ResolverResultsPatcher} patcher a function that will allow you to\n   * modify the\n   */\n  static SchemaInjector(\n    originalResolver: GraphQLFieldResolver,\n    newSchema: GraphQLSchema,\n    patcher?: ResolverResultsPatcher = undefined\n  ) {\n    return ExtendedResolver.wrap(\n      originalResolver,\n      [\n        function SchemaInjector(\n          source: any,\n          args: any,\n          context: { [argument: string]: any },\n          info: GraphQLResolveInfo\n        ) {\n          if (arguments.length === 3 && context.schema) {\n            context.schema = newSchema\n            context.rootValue = stripResolversFromSchema(newSchema)\n          }\n          else if (arguments.length === 4 && info.schema) {\n            info.schema = newSchema\n            info.rootValue = stripResolversFromSchema(newSchema)\n          }\n        },\n      ],\n      [ ],\n      patcher\n    )\n  }\n\n  /**\n   * All instances of `ExtendedResolver` are Proxies to the instantiated\n   * class with a specially defined `.apply` handler to make their custom\n   * execution flow work.\n   *\n   * @type {Object}\n   */\n  static get handler(): Object {\n    return {\n      /**\n       * Reduce the results of each resolver in the list, including\n       * the original resolver. Calling each in order with the same\n       * parameters and returning the coalesced results\n       *\n       * @param {mixed} target this should always be the object context\n       * @param {mixed} thisArg the `this` object for the context of the\n       * function calls\n       * @param {Array<mixed>} args the arguments object as seen in all\n       * graphql resolvers\n       * @return {mixed} either null or some value as would have been returned\n       * from the call of a graphql field resolver\n       */\n      async apply(target, thisArg, args) {\n        // Ensure we have arguments as an array so we can concat results in\n        // each pass of the reduction process\n        let myArgs = Array.isArray(args)\n          ? args\n          : Array.from((args && args) || [])\n\n\n        let results = {}\n        let result\n\n        for (let fn of target[listing]) {\n          try {\n            result = await fn.apply(\n              thisArg || target,\n              myArgs.concat(results)\n            )\n          }\n          catch (error) {\n            throw new WrappedResolverExecutionError(\n              error,\n              this,\n              target[listing].indexOf(fn),\n              myArgs.concat(results),\n              thisArg || target\n            );\n          }\n\n          if (\n            results &&\n            results instanceof Object &&\n            result &&\n            result instanceof Object\n          ) {\n            Object.assign(results, result)\n          }\n          else {\n            results = result\n          }\n        }\n\n        if (target[patcher] && target[patcher] instanceof Function) {\n          try {\n            results = await target[patcher].call(thisArg || target, results)\n          }\n          catch (error) {\n            throw new ResolverResultsPatcherError(\n              error,\n              target[patcher],\n              (thisArg || target),\n              results\n            )\n          }\n        }\n\n        return results\n      },\n    }\n  }\n}\n"]}