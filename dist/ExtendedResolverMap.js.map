{"version":3,"sources":["../src/ExtendedResolverMap.js"],"names":["ExtendedResolverMap","constructor","config","schema","sdl","resolvers","Symbol","iterator","key","Object","keys","value","bind","from","Schemata","buildResolvers"],"mappings":";;;;;;;AAEA;;AAKA;;;;;;;;AAQO,MAAMA,mBAAN,CAA0B;;AAK/B;;;;;;;;AAQAC,cAAYC,MAAZ,EAA+C;AAC7C,SAAKC,MAAL,GAAcD,OAAOC,MAArB;AACA,SAAKC,GAAL,GAAWF,OAAOE,GAAlB;AACA,SAAKC,SAAL,GAAiBH,OAAOG,SAAxB;AACD;;AAED;;;;;;;;AAQA,OAAKC,OAAOC,QAAZ,IAAkC;AAChC,WAAO,aAAY;AACjB,WAAK,IAAIC,GAAT,IAAgBC,OAAOC,IAAP,CAAY,KAAKL,SAAjB,CAAhB,EAA6C;AAC3C,cAAM,EAAEG,GAAF,EAAOG,OAAO,KAAKN,SAAL,CAAeG,GAAf,CAAd,EAAN;AACD;AACF,KAJM,CAILI,IAJK,CAIA,IAJA,CAAP;AAKD;;AAED;;;;;;;;;AASA,SAAOC,IAAP,CAAYX,MAAZ,EAA8D;AAC5D,QAAIA,kBAAkBY,kBAAtB,EAAgC;AAC9B,YAAM,EAAEX,MAAF,EAAUC,GAAV,KAAkBF,MAAxB;AACA,YAAMG,YAAYH,OAAOa,cAAP,EAAlB;;AAEA,aAAO,IAAIf,mBAAJ,CAAwB,EAAEG,MAAF,EAAUC,GAAV,EAAeC,SAAf,EAAxB,CAAP;AACD,KALD,MAMK;AACH,aAAO,IAAIL,mBAAJ,CAAwBE,MAAxB,CAAP;AACD;AACF;AAtD8B;QAApBF,mB,GAAAA,mB","file":"ExtendedResolverMap.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport { Schemata } from './Schemata'\n\nimport type { GraphQLSchema } from 'graphql'\nimport type { ExtendedResolverMapConfig, SchemataConfigUnion } from './types'\n\n/**\n * A class that stores information about a set of resolvers and their\n * associated GraphQLSchema (or the sdl to make one), such that when\n * multiple SDL/Schema merges occur the subsequently merged Schemas have\n * a history of the unbound resolver functiosn from previous merges (in order)\n *\n * @class ExtendedResovlerMap\n */\nexport class ExtendedResolverMap {\n  schema: ?GraphQLSchema\n  sdl: ?(string | Schemata)\n  resolvers: ?{ [string]: string }\n\n  /**\n   * The constructor takes an object with at least SDL or a GraphQLSchema and\n   * a resolver map object of untainted and unbound resolver functions\n   *\n   * @constructor\n   * @param {ExtendedResolverMapConfig} config an object conforming to the\n   * flow type `ExtendedResolverMapConfig` as defined above.\n   */\n  constructor(config: ExtendedResolverMapConfig) {\n    this.schema = config.schema\n    this.sdl = config.sdl\n    this.resolvers = config.resolvers\n  }\n\n  /**\n   * A useful iterator on instances of ExtendedResolverMap that yields a\n   * key and value for each entry found in the resolvers object set on this\n   * instance\n   *\n   * @return {Function} a bound generator function that iterates over the\n   * key/value props of the internal .resovlers property\n   */\n  get [Symbol.iterator](): Function {\n    return function*() {\n      for (let key of Object.keys(this.resolvers)) {\n        yield { key, value: this.resolvers[key] }\n      }\n    }.bind(this)\n  }\n\n  /**\n   * A shorthand way to create a new instance of `ExtendedResolverMap`. In\n   * the case that an instance of Schemata is passed in, the schema\n   * property is first attempted as\n   *\n   * @param {SchemataConfigUnion} config the same config object passed\n   * to the constructor or an instance of Schemata\n   * @return {ExtendedResolverMap} a new instance of `ExtendedResolverMap`\n   */\n  static from(config: SchemataConfigUnion): ExtendedResolverMap {\n    if (config instanceof Schemata) {\n      const { schema, sdl } = config\n      const resolvers = config.buildResolvers()\n\n      return new ExtendedResolverMap({ schema, sdl, resolvers })\n    }\n    else {\n      return new ExtendedResolverMap(config)\n    }\n  }\n}\n"]}