{"version":3,"file":"ExtendedResolverMap.js","names":["_Schemata","require","ExtendedResolverMap","constructor","config","schema","sdl","resolvers","Symbol","iterator","key","Object","keys","value","bind","from","Schemata","buildResolvers","exports"],"sources":["../src/ExtendedResolverMap.js"],"sourcesContent":["// @ts-check\n\nimport { Schemata } from './Schemata'\n\nimport type { GraphQLSchema } from 'graphql'\nimport type { ExtendedResolverMapConfig, SchemataConfigUnion } from './types'\n\n/**\n * A class that stores information about a set of resolvers and their\n * associated GraphQLSchema (or the sdl to make one), such that when\n * multiple SDL/Schema merges occur the subsequently merged Schemas have\n * a history of the unbound resolver functiosn from previous merges (in order)\n *\n * @class ExtendedResovlerMap\n */\nexport class ExtendedResolverMap {\n  schema: ?GraphQLSchema\n  sdl: ?(string | Schemata)\n  resolvers: ?{ [string]: string }\n\n  /**\n   * The constructor takes an object with at least SDL or a GraphQLSchema and\n   * a resolver map object of untainted and unbound resolver functions\n   *\n   * @constructor\n   * @param {ExtendedResolverMapConfig} config an object conforming to the\n   * flow type `ExtendedResolverMapConfig` as defined above.\n   */\n  constructor(config: ExtendedResolverMapConfig) {\n    this.schema = config.schema\n    this.sdl = config.sdl\n    this.resolvers = config.resolvers\n  }\n\n  /**\n   * A useful iterator on instances of ExtendedResolverMap that yields a\n   * key and value for each entry found in the resolvers object set on this\n   * instance\n   *\n   * @return {Function} a bound generator function that iterates over the\n   * key/value props of the internal .resovlers property\n   */\n  get [Symbol.iterator](): Function {\n    return function*() {\n      for (let key of Object.keys(this.resolvers)) {\n        yield { key, value: this.resolvers[key] }\n      }\n    }.bind(this)\n  }\n\n  /**\n   * A shorthand way to create a new instance of `ExtendedResolverMap`. In\n   * the case that an instance of Schemata is passed in, the schema\n   * property is first attempted as\n   *\n   * @param {SchemataConfigUnion} config the same config object passed\n   * to the constructor or an instance of Schemata\n   * @return {ExtendedResolverMap} a new instance of `ExtendedResolverMap`\n   */\n  static from(config: SchemataConfigUnion): ExtendedResolverMap {\n    if (config instanceof Schemata) {\n      const { schema, sdl } = config\n      const resolvers = config.buildResolvers()\n\n      return new ExtendedResolverMap({ schema, sdl, resolvers })\n    }\n    else {\n      return new ExtendedResolverMap(config)\n    }\n  }\n}\n"],"mappings":";;;;;;AAEA,IAAAA,SAAA,GAAAC,OAAA;AAFA;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,mBAAmB,CAAC;EAK/B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,MAAiC,EAAE;IAC7C,IAAI,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM;IAC3B,IAAI,CAACC,GAAG,GAAGF,MAAM,CAACE,GAAG;IACrB,IAAI,CAACC,SAAS,GAAGH,MAAM,CAACG,SAAS;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE,KAAKC,MAAM,CAACC,QAAQ,IAAc;IAChC,OAAO,aAAY;MACjB,KAAK,IAAIC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACL,SAAS,CAAC,EAAE;QAC3C,MAAM;UAAEG,GAAG;UAAEG,KAAK,EAAE,IAAI,CAACN,SAAS,CAACG,GAAG;QAAE,CAAC;MAC3C;IACF,CAAC,CAACI,IAAI,CAAC,IAAI,CAAC;EACd;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOC,IAAIA,CAACX,MAA2B,EAAuB;IAC5D,IAAIA,MAAM,YAAYY,kBAAQ,EAAE;MAC9B,MAAM;QAAEX,MAAM;QAAEC;MAAI,CAAC,GAAGF,MAAM;MAC9B,MAAMG,SAAS,GAAGH,MAAM,CAACa,cAAc,CAAC,CAAC;MAEzC,OAAO,IAAIf,mBAAmB,CAAC;QAAEG,MAAM;QAAEC,GAAG;QAAEC;MAAU,CAAC,CAAC;IAC5D,CAAC,MACI;MACH,OAAO,IAAIL,mBAAmB,CAACE,MAAM,CAAC;IACxC;EACF;AACF;AAACc,OAAA,CAAAhB,mBAAA,GAAAA,mBAAA","ignoreList":[]}