{"version":3,"file":"GraphQLExtension.js","names":["_Schemata","require","_dynamicImport","_fs","_promises","_path","_util","_utils","StandardSDLExtensions","exports","StandardJSExtensions","StandardTSExtensions","StandardResolverExtensions","AllSchemataExtensions","resolvedPaths","givenPath","tryExts","doNotRemoveTsExtensions","supportsNativeTypeScript","tsExt","indexOfTSExt","indexOf","splice","hasExt","filePath","parse","String","ext","exists","promisify","fsExists","resolved","resolve","ifParsedPath","p","format","parsed","base","result","sdl","resolver","unknown","hasValues","includes","push","index","tryParsed","tryPath","tryTrue","console","log","resolvedPath","paths","graphQLExtensionHandler","module","filename","importGraphQL","error","path","process","nextTick","cache","undefined","register","extensions","deregister","importResolvedGraphQL","options","conflictResolver","prevResolver","newResolver","value","content","_","n","toString","apply","syncConflictResolver","conflictResolverHoF","prev","conf","sdlPath","readFile","schemata","Schemata","join","astNode","ast","schema","resolversPath","resolvers","resolverPath","asyncTryCatch","dynamicImport","mergeResolvers","target","source","pathSoFar","key","Object","entries","Array","isArray","existingResolver","name","object","conflictingResolver","keys","length","clearSchema","typeDefs","resolverName","remext","fn","_default","default"],"sources":["../src/GraphQLExtension.js"],"sourcesContent":["import { Schemata } from './Schemata'\nimport { dynamicImport, supportsNativeTypeScript } from './dynamicImport'\n\nimport { exists as fsExists } from 'fs'\nimport { readFile } from 'fs/promises'\nimport { resolve, parse, format } from 'path'\nimport { promisify } from 'util'\nimport { asyncTryCatch, ifParsedPath } from './utils'\n\n/**\n * Includes common Schema Definition Language file extensions. Typically they\n * are .graphql or .gql files, but less commonly are also .typedef or .sdl\n * files.\n *\n * @type {string[]}\n */\nexport const StandardSDLExtensions = ['.graphql', '.gql', '.typedef', '.sdl']\n\n/**\n * Includes common JavaScript file extensions. Typically these include .js,\n * .mjs (Module or ESM JavaScript) and .cjs (CommonJS JavaScript).\n *\n * @type {string[]}\n */\nexport const StandardJSExtensions = ['.js', '.cjs', '.mjs']\n\n/**\n * Includes common TypeScript file extensions supported by recent versions of\n * NodeJS. Typically these are .ts, .mts (Modele or ESM TypeScript) and\n * .cts (CommonJS TypeScript) files.\n *\n * @type {string[]}\n */\nexport const StandardTSExtensions = ['.ts', '.cts', '.mts']\n\n/**\n * The combined arrays of `StandardJSExtensions` and `StandardTSExtensions`.\n *\n * @type {string[]}\n * @see {@link StandardJSExtensions}\n * @see {@link StandardTSExtensions}\n */\nexport const StandardResolverExtensions = [\n  ...StandardJSExtensions,\n  ...StandardTSExtensions,\n]\n\n/**\n * The combined arrays of `StandardJSExtensions` and `StandardTSExtensions` as\n * well as `StandardSDLExtensions`.\n *\n * @type {string[]}\n * @see {@link StandardJSExtensions}\n * @see {@link StandardTSExtensions}\n */\nexport const AllSchemataExtensions = [\n  ...StandardSDLExtensions,\n  ...StandardResolverExtensions,\n]\n\n/**\n * Resolves the given path to an existing set of file paths based on known\n * or specified extensions. A resulting object will always be returned, even\n * if no paths could be found.\n *\n * The function performs a series of checks and transformations on the\n * `givenPath` input to ascertain its validity and attempt to resolve it to an\n * existing file. Initially, it discerns whether `givenPath` already has a file\n * extension. If it does, and the file exists, it returns the resolved path.\n * If not, it iterates through a list of file extensions (provided in `tryExts`\n * or defaults to ['.js', '.cjs', '.mjs', '.ts', '.cts', '.mts']), appending\n * each extension to `givenPath`, checking the existence of the resultant file,\n * and returning the path upon successful resolution.\n *\n * Utilizes functions from the 'fs', 'fs/promises', and 'path' modules of\n * Node.js, as well as a custom `Schemata` import. It employs the `promisify`\n * utility to handle callback-based `fs` functions in a promise oriented manner.\n *\n * @note runtime loading of TypeScript modules is only supported in a few case;\n * 1. if the appropriate --experimental flags are present, 2. if a node wrapper\n * like `tsx` or `ts-node` are being used. The function\n * `supportsNativeTypeScript()` is used to check for this.\n *\n * @param {string|object} givenPath - The file path to be resolved. Should be\n * a string representing a relative or absolute path to a file, with or without\n * a file extension. Alternatively, if the output of a call to parse() from the\n * `node:path` library is supplied, it will be formatted to a string and used\n * that way.\n * @param {string[]?} [tryExts=AllSchemataExtensions] -\n * An optional array of string file extensions to attempt appending to\n * `givenPath` if it lacks an extension.\n * @param {boolean?} [doNotRemoveTsExtensions=false] should always be false\n * unless the Schemata library hasn't been upgraded and nodejs now allows\n * loading of TypeScript files without any flags or using non-experimental\n * flags.\n * @returns {Promise<object>} A promise that resolves to an object with three\n * properties: `sdl`, `resolver` and `unknown`. Each of these properties is\n * an array with 0 or more strings pointing to existing files that fall into\n * one of three categories. If the file is a known SDL extension type, it goes\n * into `.sdl`, likewise if it is any known resolver type (JS or TS), it goes\n * into `.resolver`, lastly, it goes into `.unknown` if the neither of the two\n * other categories are matched.\n * @throws Will throw an error if any of the filesystem operations fail, for\n * instance due to insufficient permissions.\n *\n * @see {@link StandardJSExtensions}\n * @see {@link StandardTSExtensions}\n * @see {@link StandardResolverExtensions}\n * @see {@link AllSchemataExtensions}\n *\n * @example\n * // Assume a file named 'example.js' exists in the current directory\n * // Outputs: {\n * //   sdl: [],\n * //   resolver: ['/absolute/path/to/example.js'],\n * //   unknown: [],\n * //   hasValues: true\n * // }\n * resolvedPaths('./example').then(resolved => console.log(resolved));\n *\n * // Assume a file named 'example.graphql' and 'example.js' exists in the\n * // current directory\n * // Outputs: {\n * //   sdl: ['/absolute/path/to/example.graphql'],\n * //   resolver: ['/absolute/path/to/example.js'],\n * //   unknown: [],\n * //   hasValues: true\n * // }\n * resolvedPaths('./example').then(resolved => console.log(resolved));\n */\nexport async function resolvedPaths(\n  givenPath,\n  tryExts = AllSchemataExtensions,\n  doNotRemoveTsExtensions = false\n) {\n  if (!supportsNativeTypeScript() && !doNotRemoveTsExtensions) {\n    for (const tsExt of StandardTSExtensions) {\n      const indexOfTSExt = tryExts.indexOf(tsExt)\n\n      if (~indexOfTSExt) {\n        tryExts.splice(indexOfTSExt, 1)\n      }\n    }\n  }\n\n  const hasExt = filePath => !!(parse(String(filePath)).ext)\n  const exists = promisify(fsExists)\n  const resolved = resolve(ifParsedPath(givenPath, p => format(p), givenPath))\n\n  // If we don't empty `base`, then format() will not take the new extension\n  const parsed = { ...parse(resolved), ...{ base: '' } }\n\n  // We want to capture any SDL extensions separate from any Resolver extensions\n  const result = {\n    sdl: [],\n    resolver: [],\n    unknown: [],\n    hasValues: false,\n  }\n\n  if (parsed.ext && (await exists(resolved))) {\n    if (StandardSDLExtensions.includes(parsed.ext)) {\n      result.sdl.push(resolved)\n    }\n    else if (StandardResolverExtensions.includes(parsed.ext)) {\n      result.resolver.push(resolved)\n    }\n    else {\n      result.unknown.push(resolved)\n    }\n\n    const index = tryExts.indexOf(parsed.ext)\n    if (~index) {\n      tryExts.splice(index, 1)\n    }\n\n    result.hasValues = true;\n  }\n\n  for (let ext of tryExts) {\n    let tryParsed = {...parsed, ...{ ext }}\n    let tryPath = format(tryParsed)\n    let tryTrue = await exists(tryPath)\n\n    console.log(`Trying ${ext}...${tryPath}? ${tryTrue}`)\n\n    if (tryTrue) {\n      if (StandardSDLExtensions.includes(ext)) {\n        result.sdl.push(tryPath)\n      }\n      else if (StandardResolverExtensions.includes(ext)) {\n        result.resolver.push(tryPath)\n      }\n      else {\n        result.unknown.push(tryPath)\n      }\n\n      result.hasValues = true\n    }\n  }\n\n  return result\n}\n\n/**\n * Resolves the given path to an existing file path by attempting to append\n * provided or default file extensions, and returns the resolved file path. This\n * function actually calls {@link resolvedPaths} and returns the first SDL file\n * path, followed by the first resolver file path, followed by the first unknown\n * file path, in that order. If no file path could be found, undefined is\n * returned\n *\n * The function performs a series of checks and transformations on the\n * `givenPath` input to ascertain its validity and attempt to resolve it to an\n * existing file. Initially, it discerns whether `givenPath` already has a file\n * extension. If it does, and the file exists, it returns the resolved path.\n * If not, it iterates through a list of file extensions (provided in `tryExts`\n * or defaults to all known Schemata file type extensions), appending each\n * extension to `givenPath`, checking the existence of the resultant file,\n * and returning the path upon successful resolution.\n *\n * Utilizes functions from the 'fs', 'fs/promises', and 'path' modules of\n * Node.js, as well as a custom `Schemata` import. It employs the `promisify`\n * utility to handle callback-based `fs` functions in a promise oriented manner.\n *\n * @note runtime loading of TypeScript modules is only supported in a few case;\n * 1. if the appropriate --experimental flags are present, 2. if a node wrapper\n * like `tsx` or `ts-node` are being used. The function\n * `supportsNativeTypeScript()` is used to check for this.\n *\n * @param {string|object} givenPath - The file path to be resolved. Should be\n * a string representing a relative or absolute path to a file, with or without\n * a file extension. Alternatively, if the output of a call to parse() from the\n * `node:path` library is supplied, it will be formatted to a string and used\n * that way.\n * @param {string[]?} [tryExts=AllSchemataExtensions] -\n * An optional array of string file extensions to attempt appending to\n * `givenPath` if it lacks an extension.\n * @param {boolean?} [doNotRemoveTsExtensions=false] should always be false\n * unless the Schemata library hasn't been upgraded and nodejs now allows\n * loading of TypeScript files without any flags or using non-experimental\n * flags.\n * @returns {Promise<string>} A promise that resolves to a string\n * representing the path to an existing file, or undefined if no path could\n * be resolved. This will return the first found artifact from a call to\n * {@link resolvedPaths} in the following order:\n * `result?.[sdl|resolver|unknown]?.[0]`\n *\n * @throws Will throw an error if any of the filesystem operations fail, for\n * instance due to insufficient permissions.\n *\n * @see {@link StandardJSExtensions}\n * @see {@link StandardTSExtensions}\n * @see {@link StandardResolverExtensions}\n * @see {@link AllSchemataExtensions}\n *\n * @example\n * // Assume a file named 'example.js' exists in the current directory\n * // Outputs: '/absolute/path/to/example.js'\n * resolvedPath('./example').then(resolved => console.log(resolved));\n *\n * // Outputs: undefined (if 'example.ts' doesn't exist)\n * resolvedPath('./example.ts').then(resolved => console.log(resolved));\n */\nexport async function resolvedPath(\n givenPath,\n tryExts = AllSchemataExtensions,\n doNotRemoveTsExtensions = false\n) {\n  const paths = resolvedPaths(givenPath, tryExts, doNotRemoveTsExtensions)\n\n  return paths.sdl?.[0] ?? paths.resolver?.[0] ?? paths.unknown?.[0]\n}\n\n/**\n * Adds the ability to `require` or `import` files ending in a `.graphql`\n * extension. The exports returned from such an import consist of four\n * major values and one default value.\n *\n * values:\n *   astNode   - an ASTNode document object representing the SDL contents\n *               of the .graphql file contents. Null if the text is invalid\n *   resovlers - if there is an adjacent file with the same name, ending in\n *               .js and it exports either a `resolvers` key or an object by\n *               default, this value will be set on the sdl object as its set\n *               resolvers/rootObj\n *   schema    - a GraphQLSchema instance object if the contents of the .graphql\n *               file represent both valid SDL and contain at least one root\n *               type such as Query, Mutation or Subscription\n *   sdl       - the string of SDL wrapped in an instance of Schemata\n *   typeDefs  - the raw string used that `sdl` wraps\n *   default   - the sdl string wrapped in an instance of Schemata is the\n *               default export\n *\n * @param {Module} module a node JS Module instance\n * @param {string} filename a fully qualified path to the file being imported\n */\nexport function graphQLExtensionHandler(module, filename) {\n  (async function() {\n    try {\n      module.exports = await importGraphQL(filename)\n    }\n    catch (error) {\n      console.error(error)\n\n      const path = await resolvedPath(filename, ['.graphql', '.gql', '.sdl'])\n      process.nextTick(() => {\n        if (path) {\n          delete require.cache[path]\n        }\n      })\n\n      module.exports = undefined\n    }\n  })()\n}\n\n/**\n * Registers the custom extension handlers for `.graphql`, `.sdl`, and `.gql` files,\n * and wraps the original `.js` extension handler to support `.graphql` files with\n * the same name.\n */\nexport function register() {\n  require.extensions = require.extensions || {}\n  require.extensions['.graphql'] = graphQLExtensionHandler\n  require.extensions['.sdl'] = graphQLExtensionHandler\n  require.extensions['.gql'] = graphQLExtensionHandler\n}\n\n/**\n * Deregisters the custom extension handlers for `.graphql`, `.sdl`, and `.gql` files,\n * and restores the original `.js` extension handler.\n */\nexport function deregister() {\n  delete require.extensions['.graphql']\n  delete require.extensions['.sdl']\n  delete require.extensions['.gql']\n}\n\n/**\n * Asynchronously imports and resolves a GraphQL schema and its resolvers from\n * given paths. Supports custom conflict resolution for resolver properties.\n *\n * @async\n * @function importResolvedGraphQL\n * @param {Object} paths - An object containing paths to SDL and resolver files.\n * @param {Object} [options] - Configuration options for importing the schema.\n * @param {(\n *   existingResolver: ResolverProperty,\n *   conflictingResolver: ResolverProperty,\n * ) => Function\n * } [options.conflictResolver]\n *   - A function to resolve conflicts between existing and new resolvers.\n *   Defaults to returning the new resolver.\n * @returns {Promise<Object|null>} The imported GraphQL schema and resolvers,\n *   or null if no valid paths are provided.\n *\n * @example\n * const paths = {\n *   sdl: ['schema.graphql'],\n *   resolver: ['resolvers.js']\n * }\n * const schema = await importResolvedGraphQL(paths)\n *\n * @example\n * const paths = {\n *   sdl: ['schema.graphql'],\n *   resolver: ['resolvers.js']\n * }\n * const options = {\n *   conflictResolver: (prev, next) => {\n *     // Custom conflict resolution logic\n *     return next.value\n *   }\n * }\n * const schema = await importResolvedGraphQL(paths, options)\n */\nexport async function importResolvedGraphQL(\n  paths,\n  options = {\n    conflictResolver(prevResolver, newResolver) {\n      return newResolver.value\n    }\n  }\n) {\n  if (!(paths?.hasValues))\n    return null\n\n  const content = []\n  let { conflictResolver } = options?.conflictResolver ?? ((_, n) => n.value)\n\n  // Wrap the received conflict resolver in an async function if it is not\n  // already asynchronous (support everything!)\n  if (!({}).toString.apply(conflictResolver).includes('AsyncFunction')) {\n    const syncConflictResolver = conflictResolver ?? ((_, n) => n.value)\n\n    async function conflictResolverHoF(prev, conf) {\n      return syncConflictResolver(prev, conf)\n    }\n\n    conflictResolver = conflictResolverHoF\n  }\n\n  for (const sdlPath of paths.sdl) {\n    content.push((await readFile(sdlPath)).toString())\n  }\n\n  const schemata = new Schemata(content.join('\\n'))\n  const astNode = schemata.ast\n  let schema = schemata.schema\n\n  let resolversPath = null\n  let resolvers = {}\n\n  for (const resolverPath of paths.resolver) {\n    const module = await asyncTryCatch(\n      async () => await dynamicImport(resolverPath),\n      async (error) => {\n        console.error(`Failed to load module ${resolverPath}`, error)\n        return {}\n      }\n    )\n\n    // Asynchronously check for conflicts in resolver properties\n    // Recursive merge for object properties\n    const mergeResolvers = async (target, source, pathSoFar = []) => {\n      for (const [key, value] of Object.entries(source)) {\n        pathSoFar.push(key)\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n          if (!target[key]) {\n            target[key] = {}\n          }\n          await mergeResolvers(target[key], value, pathSoFar)\n        } else {\n          const existingResolver = {\n            name: key,\n            value: target[key],\n            path: pathSoFar,\n            object: resolvers,\n          }\n\n          const conflictingResolver = {\n            name: key,\n            value,\n            path: pathSoFar,\n            object: module,\n          }\n\n          target[key] = await conflictResolver(\n            existingResolver,\n            conflictingResolver\n          )\n        }\n      }\n    }\n\n    await mergeResolvers(resolvers, module)\n  }\n\n  if (Object.keys(resolvers).length) {\n    schemata.clearSchema()\n    schemata.resolvers = resolvers\n    schemata.schema\n  }\n  else {\n    resolvers = null\n  }\n\n  // For all intents and purposes this is an object that can be treated like\n  // a string but that also has three extra properties; sdl, ast and schema.\n  // `ast` and `schema` invoke the functions `parse` and `buildSchema` from\n  // the 'graphql' module, respectively\n  return {\n    astNode,\n    resolvers,\n    schema,\n    sdl: schemata.sdl,\n    schemata,\n    typeDefs: schemata,\n    resolversPath,\n  }\n}\n\n/**\n * Asynchronously imports a GraphQL schema and its resolvers from a given file.\n *\n * This function attempts to resolve the provided filename with various\n * extensions and then imports the resolved GraphQL schema and its resolvers.\n * It supports custom conflict resolution for resolver properties.\n *\n * @async\n * @function importGraphQL\n * @param {string} filename - The base filename to resolve and import.\n * @param {string[]} [tryExts=AllSchemataExtensions] - An array of extensions\n *   to try when resolving the filename.\n * @param {Object} [options] - Configuration options for importing the schema.\n * @param {function(Object, Object, string): Object} [options.conflictResolver]\n *   - A function to resolve conflicts between existing and new resolvers.\n *   Defaults to returning the new resolver.\n * @returns {Promise<Object>} The imported GraphQL schema and resolvers.\n *\n * @example\n * // Import a GraphQL schema from 'schema.graphql' with default extensions\n * const schema = await importGraphQL('schema.graphql')\n *\n * @example\n * // Import a GraphQL schema with custom conflict resolution\n * const schema = await importGraphQL('schema.graphql', ['.graphql', '.gql'], {\n *   conflictResolver: (prev, next, name) => {\n *     // Custom conflict resolution logic\n *     return next\n *   }\n * })\n */\nexport async function importGraphQL(\n  filename,\n  tryExts = AllSchemataExtensions,\n  options = {\n    conflictResolver(prevResolver, newResolver, resolverName) {\n      return newResolver\n    }\n  }\n) {\n  const remext = fn => format({...parse(fn), ...{base: '', ext: ''}})\n  const paths = await resolvedPaths(filename, tryExts)\n\n  return await importResolvedGraphQL(paths, options)\n}\n\n/**\n * Sets up custom extension handlers for `.graphql`, `.sdl`, and `.gql` files,\n * and wraps the original `.js` extension handler to support `.graphql` files\n * with the same name.\n *\n * @type {Function}\n */\nexport default register\n"],"mappings":";;;;;;;;;;;;;AAAA,IAAAA,SAAA,GAAAC,OAAA;AACA,IAAAC,cAAA,GAAAD,OAAA;AAEA,IAAAE,GAAA,GAAAF,OAAA;AACA,IAAAG,SAAA,GAAAH,OAAA;AACA,IAAAI,KAAA,GAAAJ,OAAA;AACA,IAAAK,KAAA,GAAAL,OAAA;AACA,IAAAM,MAAA,GAAAN,OAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMO,qBAAqB,GAAAC,OAAA,CAAAD,qBAAA,GAAG,CAAC,UAAU,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACO,MAAME,oBAAoB,GAAAD,OAAA,CAAAC,oBAAA,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,oBAAoB,GAAAF,OAAA,CAAAE,oBAAA,GAAG,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,CAAC;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,0BAA0B,GAAAH,OAAA,CAAAG,0BAAA,GAAG,CACxC,GAAGF,oBAAoB,EACvB,GAAGC,oBAAoB,CACxB;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAME,qBAAqB,GAAAJ,OAAA,CAAAI,qBAAA,GAAG,CACnC,GAAGL,qBAAqB,EACxB,GAAGI,0BAA0B,CAC9B;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeE,aAAaA,CACjCC,SAAS,EAC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","ignoreList":[]}