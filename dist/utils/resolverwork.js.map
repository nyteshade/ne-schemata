{"version":3,"file":"resolverwork.js","names":["_typework","require","IS_TYPE_OF","exports","Symbol","for","RESOLVE_TYPE","DESCRIPTION","FIELD_DESCRIPTIONS","extractResolverInfo","resolvers","deleteFields","result","type","resolver","Object","entries","item","include","__isTypeOf","isTypeOf","__resolveType","resolveType","description","protoChain","isa","fieldDescriptions","applyTo","schema","overwrite","Reflect","has","_typeMap","defineProperty","get","configurable","enumerable","forEach","field","_fields","getter","Function","push","length","info","_default","default"],"sources":["../../src/utils/resolverwork.js"],"sourcesContent":["// @ts-check\n\nimport type { ResolverInfo, ResolverMap } from '../types'\nimport { protoChain } from './typework'\n\n/**\n * This constant type when applied to a ResolverMap object, will be picked up\n * by `extractResolverInfo` and be applied to the type on the executableSchema\n * type's `isTypeOf` property\n *\n * @type {Symbol}\n */\nexport const IS_TYPE_OF = Symbol.for('Resolver.isTypeOf')\n\n/**\n * This constant type when applied to a ResolverMap object, will be picked up\n * by `extractResolverInfo` and be applied to the type on the executableSchema\n * type's `resolveType` property\n *\n * @type {Symbol}\n */\nexport const RESOLVE_TYPE = Symbol.for('Resolver.resolveType')\n\n/**\n * A programmatic way to define a description outside of SDL. This is handy\n * when provided as a getter on the schema's type object. The getter gets invoked\n * each time the description field is accessed allowing dynamic content to be\n * presented instead of static content. Note that long running function work\n * here can slow down all items viewing the description\n *\n * @type {Symbol}\n */\nexport const DESCRIPTION = Symbol.for('Resolver.description')\n\n/**\n * Unlike `DESCRIPTION` which defines the description of the type, this symbol\n * should always point to an object whose keys are the field names and whose\n * values are the descriptions. String constant values will be converted to a\n * function that returns the constant.\n *\n * @type {Symbol}\n */\nexport const FIELD_DESCRIPTIONS = Symbol.for('Resolver.fieldDescriptions')\n\n/**\n * Walks a resolvers object and returns an array of objects with specific properties.\n *\n * @param {Object} resolvers - The resolvers object to walk.\n * @param {boolean} [deleteFields=false] - Whether to delete fields that are collected.\n * @returns {Array} - The array of objects with specified properties.\n */\nexport function extractResolverInfo(\n  resolvers: ResolverMap,\n  deleteFields: boolean = false\n): Array<ResolverInfo> {\n  const result = [];\n\n  for (const [type, resolver] of Object.entries(resolvers)) {\n    const item = { type };\n    let include = false\n\n    // Check for isTypeOf or __isTypeOf function\n    if (resolver[IS_TYPE_OF] || resolver.__isTypeOf) {\n      item.isTypeOf = resolver[IS_TYPE_OF] || resolver.__isTypeOf;\n      include = true\n      if (deleteFields) {\n        delete resolver[IS_TYPE_OF];\n        delete resolver.__isTypeOf;\n      }\n    }\n\n    // Check for resolveType or __resolveType function\n    if (resolver[RESOLVE_TYPE] || resolver.__resolveType) {\n      item.resolveType = resolver[RESOLVE_TYPE] || resolver.__resolveType;\n      include = true\n      if (deleteFields) {\n        delete resolver[RESOLVE_TYPE];\n        delete resolver.__resolveType;\n      }\n    }\n\n    // Check for description field\n    if (resolver[DESCRIPTION]) {\n      item.description = typeof resolver[DESCRIPTION] === 'string'\n        ? () => resolver[DESCRIPTION]\n        : resolver[DESCRIPTION];\n      include = true\n      if (deleteFields) {\n        delete resolver[DESCRIPTION];\n      }\n    }\n\n    // Check for the field descriptions field\n    if (\n      resolver[FIELD_DESCRIPTIONS] &&\n      protoChain(resolver[FIELD_DESCRIPTIONS]).isa(Object)\n    ) {\n      item.fieldDescriptions = resolver[FIELD_DESCRIPTIONS]\n      include = true\n      if (deleteFields) {\n        delete resolver[FIELD_DESCRIPTIONS];\n      }\n    }\n\n    // Only add item to result if it has more than just the type property\n    if (include) {\n      item.applyTo = function applyTo(schema, overwrite = false) {\n        if (Reflect.has(schema._typeMap, this.type)) {\n          let { resolveType, isTypeOf, description, fieldDescriptions } = this\n          let type = schema._typeMap[this.type]\n\n          if (resolveType && Reflect.has(type, 'resolveType')) {\n            if (!type.resolveType || overwrite) {\n              type.resolveType = resolveType\n            }\n          }\n\n          if (isTypeOf && Reflect.has(type, 'isTypeOf')) {\n            if (!type.isTypeOf || overwrite) {\n              type.isTypeOf = isTypeOf\n            }\n          }\n\n          if (description && Reflect.has(type, 'description')) {\n            if (!type.description || overwrite) {\n              Object.defineProperty(type, 'description', {\n                get: description,\n                configurable: true,\n                enumerable: true\n              })\n            }\n          }\n\n          if (fieldDescriptions && Reflect.has(type, '_fields')) {\n            Object.entries(fieldDescriptions).forEach(([field, description]) => {\n              if (!type._fields[field]?.description || overwrite) {\n                const getter = protoChain(description).isa(Function)\n                  ? description\n                  : () => description\n\n                Object.defineProperty(type._fields[field], 'description', {\n                  get: getter,\n                  configurable: true,\n                  enumerable: true\n                })\n              }\n            })\n          }\n        }\n      }\n\n      result.push(item);\n    }\n  }\n\n  if (result.length) {\n    result.applyTo = function applyTo(schema, overwrite = false) {\n      result.forEach(info => info.applyTo(schema, overwrite))\n    }\n  }\n\n  return result;\n}\n\nexport default extractResolverInfo\n"],"mappings":"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","ignoreList":[]}