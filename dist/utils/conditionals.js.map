{"version":3,"file":"conditionals.js","names":["ifThenElse","condition","then","otherwise","undefined","ifThen","tryCatch","tryFn","catchFn","thisArg","args","apply","error","asyncTryCatch","ignored","isParsedPath","value","Object","every","key","Reflect","has","ifParsedPath","parsed","format"],"sources":["../../src/utils/conditionals.js"],"sourcesContent":["/**\n * Executes a function or returns a value based on a condition. If the condition\n * is true, the `then` function or value is executed or returned. If the\n * condition is false, the `otherwise` function or value is executed or\n * returned.\n *\n * @param {boolean} condition - The condition to evaluate.\n * @param {Function|any} then - The function to execute or value to return if\n * the condition is true. If a function, the condition is passed as an argument.\n * @param {Function|any} [otherwise] - The function to execute or value to\n * return if the condition is false. If a function, the condition is passed as\n * an argument.\n *\n * @returns {any} The result of the `then` or `otherwise` function, or the\n * `then` or `otherwise` value, based on the condition.\n *\n * @example\n * const result = ifThenElse(true, () => 'Yes', () => 'No')\n * console.log(result) // Outputs: 'Yes'\n *\n * const result = ifThenElse(false, 'Yes', 'No')\n * console.log(result) // Outputs: 'No'\n */\nexport function ifThenElse(condition, then, otherwise) {\n  if (condition) {\n    if (then !== undefined) {\n      if (typeof then === 'function')\n        return then(condition)\n\n      return then\n    }\n  }\n\n  if (otherwise !== undefined) {\n    if (typeof otherwise === 'function')\n      return otherwise(condition)\n\n    return otherwise\n  }\n\n  return undefined\n}\n\n/**\n * Executes a function or returns a value based on a condition. If the condition\n * is true, the `then` function or value is executed or returned.\n *\n * @param {boolean} condition - The condition to evaluate.\n * @param {Function|any} then - The function to execute or value to return if\n * the condition is true. If a function, the condition is passed as an argument.\n *\n * @returns {any} The result of the `then` function or the `then` value, based\n * on the condition.\n *\n * @example\n * const result = ifThen(true, () => 'Yes')\n * console.log(result) // Outputs: 'Yes'\n *\n * const result = ifThen(false, 'Yes')\n * console.log(result) // Outputs: undefined\n */\nexport function ifThen(condition, then) {\n  return ifThenElse(condition, then)\n}\n\n/**\n * Executes a function and catches any errors that occur, optionally handling\n * them with a provided catch function.\n *\n * @param {Function} tryFn - The function to attempt.\n * @param {Function?} [catchFn] - The function to handle any errors thrown\n * by tryFn. Receives the error as the first argument.\n * @param {any?} [thisArg] - The value to use as `this` when calling tryFn\n * and catchFn.\n * @param {any[]?} args - Additional arguments to pass to tryFn and catchFn.\n *\n * @returns {any} The result of tryFn if it succeeds, or the result of catchFn\n * if an error occurs. If both functions fail, returns undefined.\n *\n * @example\n * function riskyOperation() {\n *   if (Math.random() > 0.5) throw new Error('Failed')\n *   return 'Success'\n * }\n *\n * function handleFailure(error) {\n *   console.error('Operation failed:', error)\n *   return 'Default value'\n * }\n *\n * const result = tryCatch(riskyOperation, handleFailure)\n * console.log(result) // Outputs: 'Success' or 'Default value'\n */\nexport function tryCatch(tryFn, catchFn, thisArg, ...args) {\n  try {\n    if (tryFn && typeof tryFn === 'function')\n      return tryFn.apply(thisArg, ...args)\n  }\n  catch (error) {\n    if (catchFn && typeof catchFn === 'function')\n      return catchFn.apply(thisArg, [error, ...args])\n  }\n\n  return undefined\n}\n\n/**\n * Executes an asynchronous function and catches any errors that occur,\n * optionally handling them with a provided catch function.\n *\n * @param {Function} tryFn - The asynchronous function to attempt.\n * @param {Function?} [catchFn] - The function to handle any errors thrown\n * by tryFn. Receives the error as the first argument.\n * @param {any?} [thisArg] - The value to use as `this` when calling tryFn\n * and catchFn.\n * @param {any[]?} args - Additional arguments to pass to tryFn and catchFn.\n *\n * @returns {Promise<any>} The result of tryFn if it succeeds, or the result\n * of catchFn if an error occurs. If both functions fail, returns the error\n * from tryFn.\n *\n * @example\n * // If we don't care about catching\n * async function fetchData() {\n *   // Simulate a fetch operation\n *   return 'data'\n * }\n * await asyncTryCatch(fetchData) // receives undefined if it fails\n *\n * @example\n * async function fetchData() {\n *   // Simulate a fetch operation\n *   return 'data'\n * }\n *\n * async function handleError(error) {\n *   console.error('Error occurred:', error)\n *   return 'default data'\n * }\n *\n * asyncTryCatch(fetchData, handleError).then(result => {\n *   console.log(result) // Outputs: 'data' or 'default data'\n * })\n */\nexport async function asyncTryCatch(tryFn, catchFn, thisArg, ...args) {\n  try {\n    return await tryFn?.apply(thisArg, ...args)\n  }\n  catch (error) {\n    if (catchFn && typeof catchFn === 'function') {\n      try {\n        return await catchFn.apply(thisArg, [error, ...args])\n      }\n      catch (ignored) { return error }\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Checks to see if the supplied value is compatible with output from node's\n * path.parse() function.\n *\n * @param {any} value any JavaScript value\n * @returns true if the supplied value is an object with the expected keys of\n * a result from a call to node's `node:path` `parse()` function call.\n */\nexport function isParsedPath(value) {\n  return (\n    // Is truthy\n    value &&\n\n    // Is of type object or an instanceof Object\n    (typeof value === 'object' || value instanceof Object) &&\n\n    // Contains the expected keys of a parsed path object result\n    ['root', 'dir', 'base', 'ext', 'name'].every(\n      key => Reflect.has(value, key)\n    )\n  )\n}\n\n/**\n * Shorthand logic to run a function or return a value if `value` is compatible\n * with node's path.parse() function.\n *\n * @param {any} value the value to check for path.parse() equivalency\n * @param {function|any} then a function or non-undefined value to return\n * in the case that `value` is path.parse() output compatible. If `then` is\n * a function, `value` is passed to it and its result is returned.\n * @param {function|any} otherwise if `value` is not path.parse() output\n * compatible, `otherwise` is returned unless it's a function in which case\n * `value` is passed to the function and the result of the call is returned.\n * @returns\n */\nexport function ifParsedPath(\n  value,\n  then = (parsed) => format(parsed),\n  otherwise\n) {\n  return ifThenElse(isParsedPath(value), then, otherwise, undefined, value)\n}"],"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASA,UAAUA,CAACC,SAAS,EAAEC,IAAI,EAAEC,SAAS,EAAE;EACrD,IAAIF,SAAS,EAAE;IACb,IAAIC,IAAI,KAAKE,SAAS,EAAE;MACtB,IAAI,OAAOF,IAAI,KAAK,UAAU,EAC5B,OAAOA,IAAI,CAACD,SAAS,CAAC;MAExB,OAAOC,IAAI;IACb;EACF;EAEA,IAAIC,SAAS,KAAKC,SAAS,EAAE;IAC3B,IAAI,OAAOD,SAAS,KAAK,UAAU,EACjC,OAAOA,SAAS,CAACF,SAAS,CAAC;IAE7B,OAAOE,SAAS;EAClB;EAEA,OAAOC,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,MAAMA,CAACJ,SAAS,EAAEC,IAAI,EAAE;EACtC,OAAOF,UAAU,CAACC,SAAS,EAAEC,IAAI,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASI,QAAQA,CAACC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE,GAAGC,IAAI,EAAE;EACzD,IAAI;IACF,IAAIH,KAAK,IAAI,OAAOA,KAAK,KAAK,UAAU,EACtC,OAAOA,KAAK,CAACI,KAAK,CAACF,OAAO,EAAE,GAAGC,IAAI,CAAC;EACxC,CAAC,CACD,OAAOE,KAAK,EAAE;IACZ,IAAIJ,OAAO,IAAI,OAAOA,OAAO,KAAK,UAAU,EAC1C,OAAOA,OAAO,CAACG,KAAK,CAACF,OAAO,EAAE,CAACG,KAAK,EAAE,GAAGF,IAAI,CAAC,CAAC;EACnD;EAEA,OAAON,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeS,aAAaA,CAACN,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAE,GAAGC,IAAI,EAAE;EACpE,IAAI;IACF,OAAO,MAAMH,KAAK,EAAEI,KAAK,CAACF,OAAO,EAAE,GAAGC,IAAI,CAAC;EAC7C,CAAC,CACD,OAAOE,KAAK,EAAE;IACZ,IAAIJ,OAAO,IAAI,OAAOA,OAAO,KAAK,UAAU,EAAE;MAC5C,IAAI;QACF,OAAO,MAAMA,OAAO,CAACG,KAAK,CAACF,OAAO,EAAE,CAACG,KAAK,EAAE,GAAGF,IAAI,CAAC,CAAC;MACvD,CAAC,CACD,OAAOI,OAAO,EAAE;QAAE,OAAOF,KAAK;MAAC;IACjC;EACF;EAEA,OAAOR,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASW,YAAYA,CAACC,KAAK,EAAE;EAClC;IACE;IACAA,KAAK;IAEL;IACC,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAYC,MAAM,CAAC;IAEtD;IACA,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,CAAC,CAACC,KAAK,CAC1CC,GAAG,IAAIC,OAAO,CAACC,GAAG,CAACL,KAAK,EAAEG,GAAG,CAC/B;EAAC;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASG,YAAYA,CAC1BN,KAAK,EACLd,IAAI,GAAIqB,MAAM,IAAKC,MAAM,CAACD,MAAM,CAAC,EACjCpB,SAAS,EACT;EACA,OAAOH,UAAU,CAACe,YAAY,CAACC,KAAK,CAAC,EAAEd,IAAI,EAAEC,SAAS,EAAEC,SAAS,EAAEY,KAAK,CAAC;AAC3E","ignoreList":[]}