{"version":3,"file":"ResolverResultsPatcherError.js","names":["_neTagFns","require","_BaseError","_interopRequireDefault","_util","e","__esModule","default","isFn","o","test","Object","prototype","toString","call","ResolverResultsPatcherError","BaseError","constructor","error","patcher","context","results","dropLowest","name","inspect","colors","depth","valueOf","wasBigArrowFunction","exports","_default"],"sources":["../../src/errors/ResolverResultsPatcherError.js"],"sourcesContent":["// @ts-check\n\nimport { inline, dropLowest } from 'ne-tag-fns'\nimport BaseError from './BaseError.js'\nimport { inspect } from 'util'\n\nimport type { ResolverResultsPatcher } from '../types'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * The `ResolverResultsPatcherError` can occur as the `ExtendedResolver` is\n * finishing and the final results are passed to a patcher function for final\n * inspection or modification. If an error is thrown at this time, the values\n * passed to the function are captured here for review by the programmer using\n * them\n *\n * @class ResolverResultsPatcherError\n */\nexport class ResolverResultsPatcherError extends BaseError {\n  /**\n   * The `ResolverResultsPatcher` function that failed.\n   *\n   * @type {ResolverResultsPatcher}\n   */\n  patcher;\n\n  /**\n   * The `this` value passed to the function as it was executed. Note that\n   * this value is irrelevant if the function passed was a big arrow function\n   *\n   * @type {unknown}\n   */\n  context;\n\n  /**\n   * The `results` value before the internal patcher that failed was thrown.\n   * This does not include the results of the erroring function in question as\n   * no value was ever reached before the exception was thrown (in theory)\n   *\n   * @type {unknown}\n   */\n  results;\n\n  /**\n   * Creates a new instance of `ResolverResultsPatcherError`.\n   *\n   * @constructor\n   *\n   * @param {string|Error} error the actual thrown error or error message\n   * @param {ResolverResultsPatcher} patcher the function called during the\n   * time of the error\n   * @param {unknown} context the `this` arg applied to the call when the error\n   * occurred; use `resolverResultsPatcherError.wasBigArrowFunction` to check\n   * if the `this` arg would have had any results\n   * @param {unknown} results the final results from the `ExtendedResolver`\n   * execution that were passed to the patcher function\n   */\n  constructor(error, patcher, context, results) {\n    super(error)\n\n    this.patcher = patcher\n    this.context = context\n    this.results = results\n  }\n\n  /**\n   * Description of the ResolverResultsPatcherError error and likely cause\n   * and fix.\n   *\n   * @return {string} a string denoting the purpose/cause of this error class\n   */\n  toString() {\n    return dropLowest`\n      The patcher function failed to execute against the results of the\n      'ExtendedResolver' execution. The patcher function had a name of\n      '${this.patcher && this.patcher.name || null}'.\n\n      The context of the patcher was:\n      ${inspect(this.context, {colors: true, depth: 8})}\n\n      The results passed to the function were:\n      ${inspect(this.results, {colors: true, depth: 8})}\n\n      Original Stack Trace\n      ${this.error.toString()}\n\n    `\n  }\n\n  /**\n   * Modify the `valueOf()` function to mirror the `toString()` functionality\n   *\n   * @return {string} an identical string to `.toString()`\n   */\n  valueOf() {\n    return this.toString()\n  }\n\n  /**\n   * A programmatic attempt to determine if the function that failed was a\n   * big arrow function. This means the function was pre-bound and the\n   * `context` set at the time of execution would have been ignored.\n   *\n   * @function wasBigArrowFunction\n   *\n   * @return {boolean} true if the failed function was a big arrow or\n   * pre-bound function; false if the `context` value should have been passed\n   * successfully to the execution context\n   */\n  get wasBigArrowFunction() {\n    const patcher = this.patcher\n\n    if (patcher && isFn(patcher)) {\n      return typeof patcher.prototype === 'undefined'\n    }\n\n    return false\n  }\n}\n\nexport default ResolverResultsPatcherError\n"],"mappings":";;;;;;AAEA,IAAAA,SAAA,GAAAC,OAAA;AACA,IAAAC,UAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,KAAA,GAAAH,OAAA;AAA8B,SAAAE,uBAAAE,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AAJ9B;;AAQA,MAAMG,IAAI,GAAGC,CAAC,IAAI,YAAY,CAACC,IAAI,CAACC,MAAM,CAACC,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACL,CAAC,CAAC,CAAC;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMM,2BAA2B,SAASC,kBAAS,CAAC;EACzD;AACF;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,KAAK,EAAEC,OAAO,EAAEC,OAAO,EAAEC,OAAO,EAAE;IAC5C,KAAK,CAACH,KAAK,CAAC;IAEZ,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,OAAO,GAAGA,OAAO;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;EACER,QAAQA,CAAA,EAAG;IACT,OAAO,IAAAS,oBAAU;AACrB;AACA;AACA,SAAS,IAAI,CAACH,OAAO,IAAI,IAAI,CAACA,OAAO,CAACI,IAAI,IAAI,IAAI;AAClD;AACA;AACA,QAAQ,IAAAC,aAAO,EAAC,IAAI,CAACJ,OAAO,EAAE;MAACK,MAAM,EAAE,IAAI;MAAEC,KAAK,EAAE;IAAC,CAAC,CAAC;AACvD;AACA;AACA,QAAQ,IAAAF,aAAO,EAAC,IAAI,CAACH,OAAO,EAAE;MAACI,MAAM,EAAE,IAAI;MAAEC,KAAK,EAAE;IAAC,CAAC,CAAC;AACvD;AACA;AACA,QAAQ,IAAI,CAACR,KAAK,CAACL,QAAQ,CAAC,CAAC;AAC7B;AACA,KAAK;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEc,OAAOA,CAAA,EAAG;IACR,OAAO,IAAI,CAACd,QAAQ,CAAC,CAAC;EACxB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIe,mBAAmBA,CAAA,EAAG;IACxB,MAAMT,OAAO,GAAG,IAAI,CAACA,OAAO;IAE5B,IAAIA,OAAO,IAAIX,IAAI,CAACW,OAAO,CAAC,EAAE;MAC5B,OAAO,OAAOA,OAAO,CAACP,SAAS,KAAK,WAAW;IACjD;IAEA,OAAO,KAAK;EACd;AACF;AAACiB,OAAA,CAAAd,2BAAA,GAAAA,2BAAA;AAAA,IAAAe,QAAA,GAAAD,OAAA,CAAAtB,OAAA,GAEcQ,2BAA2B","ignoreList":[]}