{"version":3,"file":"BaseError.js","names":["_neTagFns","require","_util","BaseError","Error","constructor","error","message","fileName","lineNumber","String","toString","prototype","console","inline","name","inspect","custom","depth","options","Proxy","get","target","property","receiver","hasOwnProperty","Reflect","Symbol","toStringTag","exports","_default","default"],"sources":["../../src/errors/BaseError.js"],"sourcesContent":["// @ts-check\n// $FlowFixMe[prop-missing]\n// $FlowFixMe[incompatible-call]\n\nimport { inline } from 'ne-tag-fns'\nimport { inspect } from 'util'\n\n/**\n * The BaseError class provides a simply stock way to wrap errors in a more\n * concise error type for use within the project. All normal error fields are\n * passed through to the wrapped error class if the default error contains\n * the requested property; failing that, it is passed on to the subclass.\n *\n * It is highly recommended\n */\nexport class BaseError extends Error {\n  /**\n   * The error this error wraps.\n   *\n   * @type {Error}\n   */\n  error;\n\n  /**\n   * Creates a new BaseError type that wraps either an existing error or\n   * uses this error instantiation with the given error message.\n   *\n   * @constructor\n   * @param {Error | string} error the error or message used to create an\n   * instance\n   */\n  constructor(error) {\n    super(error.message || error, error?.fileName, error?.lineNumber)\n\n    this.error = error instanceof String ? this : error\n\n    if (this.toString === Error.prototype.toString) {\n      console.error(inline`\n        Class \\`${this.constructor.name}\\` does not correctly implement or\n        override the \\`toString()\\` function in order to describe the cause\n        of this named error. Please remedy this.\n      `)\n    }\n\n    if (inspect.custom) {\n      this[inspect.custom] = (depth, options) => this.toString()\n    }\n    else {\n      this.inspect = (depth, options) => this.toString()\n    }\n\n    return new Proxy(this, {\n      get(target, property, receiver) {\n        if (this.error && this.error.hasOwnProperty(property)) {\n          return this.error[property]\n        }\n        else {\n          return Reflect.get(target, property, receiver)\n        }\n      }\n    })\n  }\n\n  /**\n   * All BaseError children will show `[object <class name>]` as their internal\n   * class naming when used with `Object.prototype.toString.call` or `apply`.\n   *\n   * @type {string}\n   */\n  get [Symbol.toStringTag]() {\n    return this.constructor.name\n  }\n}\n\nexport default BaseError\n"],"mappings":";;;;;;AAIA,IAAAA,SAAA,GAAAC,OAAA;AACA,IAAAC,KAAA,GAAAD,OAAA;AALA;AACA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAME,SAAS,SAASC,KAAK,CAAC;EACnC;AACF;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,WAAWA,CAACC,KAAK,EAAE;IACjB,KAAK,CAACA,KAAK,CAACC,OAAO,IAAID,KAAK,EAAEA,KAAK,EAAEE,QAAQ,EAAEF,KAAK,EAAEG,UAAU,CAAC;IAEjE,IAAI,CAACH,KAAK,GAAGA,KAAK,YAAYI,MAAM,GAAG,IAAI,GAAGJ,KAAK;IAEnD,IAAI,IAAI,CAACK,QAAQ,KAAKP,KAAK,CAACQ,SAAS,CAACD,QAAQ,EAAE;MAC9CE,OAAO,CAACP,KAAK,CAAC,IAAAQ,gBAAM;AAC1B,kBAAkB,IAAI,CAACT,WAAW,CAACU,IAAI;AACvC;AACA;AACA,OAAO,CAAC;IACJ;IAEA,IAAIC,aAAO,CAACC,MAAM,EAAE;MAClB,IAAI,CAACD,aAAO,CAACC,MAAM,CAAC,GAAG,CAACC,KAAK,EAAEC,OAAO,KAAK,IAAI,CAACR,QAAQ,CAAC,CAAC;IAC5D,CAAC,MACI;MACH,IAAI,CAACK,OAAO,GAAG,CAACE,KAAK,EAAEC,OAAO,KAAK,IAAI,CAACR,QAAQ,CAAC,CAAC;IACpD;IAEA,OAAO,IAAIS,KAAK,CAAC,IAAI,EAAE;MACrBC,GAAGA,CAACC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,EAAE;QAC9B,IAAI,IAAI,CAAClB,KAAK,IAAI,IAAI,CAACA,KAAK,CAACmB,cAAc,CAACF,QAAQ,CAAC,EAAE;UACrD,OAAO,IAAI,CAACjB,KAAK,CAACiB,QAAQ,CAAC;QAC7B,CAAC,MACI;UACH,OAAOG,OAAO,CAACL,GAAG,CAACC,MAAM,EAAEC,QAAQ,EAAEC,QAAQ,CAAC;QAChD;MACF;IACF,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE,KAAKG,MAAM,CAACC,WAAW,IAAI;IACzB,OAAO,IAAI,CAACvB,WAAW,CAACU,IAAI;EAC9B;AACF;AAACc,OAAA,CAAA1B,SAAA,GAAAA,SAAA;AAAA,IAAA2B,QAAA,GAAAD,OAAA,CAAAE,OAAA,GAEc5B,SAAS","ignoreList":[]}