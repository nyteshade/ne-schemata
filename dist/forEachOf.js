"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UNIONS = exports.TypeMap = exports.TYPES = exports.SCALARS = exports.ROOT_TYPES = exports.INTERFACES = exports.INPUT_TYPES = exports.HIDDEN = exports.ENUMS = exports.ALL = void 0;
exports.forEachField = forEachField;
exports.forEachOf = forEachOf;
var _graphql = require("graphql");
// @ts-check

// Create constants for each of the types allowed, over which one might
// iterate. These can be bitmasked to include multiple types; i.e. for both
// type and enums, pass TYPES | ENUMS for the types parameter. It
// defaults to simply types.
const ALL = exports.ALL = 1;
const TYPES = exports.TYPES = 2;
const INTERFACES = exports.INTERFACES = 4;
const ENUMS = exports.ENUMS = 8;
const UNIONS = exports.UNIONS = 16;
const SCALARS = exports.SCALARS = 32;
const ROOT_TYPES = exports.ROOT_TYPES = 64;
const INPUT_TYPES = exports.INPUT_TYPES = 128;
const HIDDEN = exports.HIDDEN = 256;
const Masks = [ALL, TYPES, INTERFACES, UNIONS, ENUMS, SCALARS, ROOT_TYPES, INPUT_TYPES];
// Create a mapping from the constant to the GraphQL type class.
const TypeMap = exports.TypeMap = new Map();
TypeMap.set(TYPES, _graphql.GraphQLObjectType);
TypeMap.set(ROOT_TYPES, _graphql.GraphQLObjectType);
TypeMap.set(INTERFACES, _graphql.GraphQLInterfaceType);
TypeMap.set(INPUT_TYPES, _graphql.GraphQLInputObjectType);
TypeMap.set(ENUMS, _graphql.GraphQLEnumType);
TypeMap.set(UNIONS, _graphql.GraphQLUnionType);
TypeMap.set(SCALARS, _graphql.GraphQLScalarType);

/**
 * Iterates over the values contained in a Schema's typeMap. If a desired
 * value is encountered, the supplied callback will be invoked. The values are
 * the constants ALL, TYPES, INTERFACES, ENUMS, UNIONS and SCALARS. Optionally
 * HIDDEN is another value that can be bitmasked together for a varied result.
 * HIDDEN exposes the values in the schema typemap that begin with a double
 * underscore.
 *
 * The signature for the function callback is as follows:
 * (
 *   type: unknown,
 *   typeName: string,
 *   typeDirectives: Array<GraphQLDirective>
 *   schema: GraphQLSchema,
 *   context: unknown,
 * ) => void
 *
 * Where:
 *   `type`           - the object instance from within the `GraphQLSchema`
 *   `typeName`       - the name of the object; "Query" for type Query and
 *                      so on.
 *   `typeDirectives` - an array of directives applied to the object or an
 *                      empty array if there are none applied.
 *   `schema`         - an instance of `GraphQLSchema` over which to iterate
 *   `context`        - usually an object, and usually the same object,
 *                      passed to the call to `makeExecutableSchema()`
 *                      or `graphql()`
 *
 * @param {Function} fn a function with a signature defined above
 * @param {mixed} context usually an object but any mixed value the denotes
 * some shared context as is used with the schema during normal runtime.
 * @param {Number} types a bitmask of one or more of the constants defined
 * above. These can be OR'ed together and default to TYPES.
 * @return {GraphQLSchema} a new schema is generated from this SDL, iterated
 * over and returned.
 */
function forEachOf(schema, fn, context, types = ALL) {
  [_graphql.GraphQLObjectType, _graphql.GraphQLInterfaceType, _graphql.GraphQLEnumType, _graphql.GraphQLUnionType, _graphql.GraphQLScalarType].forEach(t => {
    if (!t) return;
    if (!Object.getOwnPropertySymbols(t.prototype).includes(Symbol.toStringTag)) {
      Object.defineProperties(t.prototype, {
        [Symbol.toStringTag]: {
          get() {
            return this.constructor.name;
          }
        }
      });
    }
  });
  const typeMap = schema.getTypeMap();
  Object.keys(typeMap).forEach(typeName => {
    const type = typeMap[typeName];
    const hidden = (0, _graphql.getNamedType)(type).name.startsWith('__');
    const showHidden = (types & HIDDEN) === HIDDEN;
    const directives = type && type.astNode && type.astNode.directives || [];
    let doIt = (types & ALL) === ALL;
    Masks.forEach(mask => {
      if (doIt) {
        return;
      } else if ((mask & ROOT_TYPES) === ROOT_TYPES && (type === schema.getQueryType() || type === schema.getSubscriptionType() || type === schema.getMutationType())) {
        doIt = true;
        return;
      } else {
        doIt = (types & mask) === mask && type instanceof TypeMap.get(mask);
      }
    });

    // Prevent hidden items from being shown unless asked for
    doIt = doIt && (!hidden || hidden && showHidden);
    if (doIt) fn(type, typeName, directives, schema, context);
  });
}

/**
 * An extension of `forEachOf` that targets the fields of the types in the
 * schema's typeMap. This function provides more detail and allows greater
 * access to any associated `context` than the function of the same name
 * provided by the `graphql-tools` library.
 *
 * The signature for the callback function is as follows
 *
 * (
 *   type: unknown,
 *   typeName: string,
 *   typeDirectives: Array<GraphQLDirective>,
 *   field: unknown,
 *   fieldName: string,
 *   fieldArgs: Array<GraphQLArgument>,
 *   fieldDirectives: Array<GraphQLDirective>,
 *   schema: GraphQLSchema,
 *   context: unknown
 * ) => void
 *
 * Where
 *
 * Where:
 *   `type`           - the object instance from within the `GraphQLSchema`
 *   `typeName`       - the name of the object; "Query" for type Query and so on
 *   `typeDirectives` - an array of directives applied to the object or an empty
 *                      array if there are none applied.
 *   `field`          - the field in question from the type
 *   `fieldName`      - the name of the field as a string
 *   `fieldArgs`      - an array of arguments for the field in question
 *   `fieldDirectives`- an array of directives applied to the field or an empty
 *                      array should there be no applied directives
 *   `schema`         - an instance of `GraphQLSchema` over which to iterate
 *   `context`        - usually an object, and usually the same object, passed
 *                      to the call to `makeExecutableSchema()` or `graphql()`
 *
 * @param {GraphQLSchema} schema
 * @param {Function} fn a function with a signature defined above
 * @param {mixed} context usually an object but any mixed value the denotes
 * some shared context as is used with the schema during normal runtime.
 */
function forEachField(schema, fn, context, types = ALL) {
  forEachOf(schema, (type, typeName, _, context, directives) => {
    if (!type._fields) {
      return;
    }
    Object.keys(type._fields).forEach(fieldName => {
      let field = type._fields[fieldName];
      let fieldDirectives = field.astNode && field.astNode.directives || [];
      let fieldArgs = field.args || [];
      fn(type, typeName, directives, field, fieldName, fieldArgs, fieldDirectives, schema, context);
    });
  }, context, types);
}
var _default = exports.default = forEachOf;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJfZ3JhcGhxbCIsInJlcXVpcmUiLCJBTEwiLCJleHBvcnRzIiwiVFlQRVMiLCJJTlRFUkZBQ0VTIiwiRU5VTVMiLCJVTklPTlMiLCJTQ0FMQVJTIiwiUk9PVF9UWVBFUyIsIklOUFVUX1RZUEVTIiwiSElEREVOIiwiTWFza3MiLCJUeXBlTWFwIiwiTWFwIiwic2V0IiwiR3JhcGhRTE9iamVjdFR5cGUiLCJHcmFwaFFMSW50ZXJmYWNlVHlwZSIsIkdyYXBoUUxJbnB1dE9iamVjdFR5cGUiLCJHcmFwaFFMRW51bVR5cGUiLCJHcmFwaFFMVW5pb25UeXBlIiwiR3JhcGhRTFNjYWxhclR5cGUiLCJmb3JFYWNoT2YiLCJzY2hlbWEiLCJmbiIsImNvbnRleHQiLCJ0eXBlcyIsImZvckVhY2giLCJ0IiwiT2JqZWN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvdG90eXBlIiwiaW5jbHVkZXMiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImRlZmluZVByb3BlcnRpZXMiLCJnZXQiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJ0eXBlTWFwIiwiZ2V0VHlwZU1hcCIsImtleXMiLCJ0eXBlTmFtZSIsInR5cGUiLCJoaWRkZW4iLCJnZXROYW1lZFR5cGUiLCJzdGFydHNXaXRoIiwic2hvd0hpZGRlbiIsImRpcmVjdGl2ZXMiLCJhc3ROb2RlIiwiZG9JdCIsIm1hc2siLCJnZXRRdWVyeVR5cGUiLCJnZXRTdWJzY3JpcHRpb25UeXBlIiwiZ2V0TXV0YXRpb25UeXBlIiwiZm9yRWFjaEZpZWxkIiwiXyIsIl9maWVsZHMiLCJmaWVsZE5hbWUiLCJmaWVsZCIsImZpZWxkRGlyZWN0aXZlcyIsImZpZWxkQXJncyIsImFyZ3MiLCJfZGVmYXVsdCIsImRlZmF1bHQiXSwic291cmNlcyI6WyIuLi9zcmMvZm9yRWFjaE9mLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1jaGVja1xuXG5pbXBvcnQge1xuICBnZXROYW1lZFR5cGUsXG4gIEdyYXBoUUxPYmplY3RUeXBlLFxuICBHcmFwaFFMSW50ZXJmYWNlVHlwZSxcbiAgR3JhcGhRTElucHV0T2JqZWN0VHlwZSxcbiAgR3JhcGhRTEVudW1UeXBlLFxuICBHcmFwaFFMVW5pb25UeXBlLFxuICBHcmFwaFFMU2NhbGFyVHlwZSxcbiAgR3JhcGhRTFR5cGUsXG4gIEdyYXBoUUxTY2hlbWEsXG59IGZyb20gJ2dyYXBocWwnXG5cbmV4cG9ydCB0eXBlIEZvckVhY2hPZlJlc29sdmVyID0gKFxuICB0eXBlOiB1bmtub3duLFxuICB0eXBlTmFtZTogc3RyaW5nLFxuICB0eXBlRGlyZWN0aXZlczogQXJyYXk8R3JhcGhRTERpcmVjdGl2ZT4sXG4gIHNjaGVtYTogR3JhcGhRTFNjaGVtYSxcbiAgY29udGV4dDogdW5rbm93blxuKSA9PiB2b2lkXG5cbmV4cG9ydCB0eXBlIEZvckVhY2hGaWVsZFJlc29sdmVyID0gKFxuICB0eXBlOiB1bmtub3duLFxuICB0eXBlTmFtZTogc3RyaW5nLFxuICB0eXBlRGlyZWN0aXZlczogQXJyYXk8R3JhcGhRTERpcmVjdGl2ZT4sXG4gIGZpZWxkOiB1bmtub3duLFxuICBmaWVsZE5hbWU6IHN0cmluZyxcbiAgZmllbGRBcmdzOiBBcnJheTxHcmFwaFFMQXJndW1lbnQ+LFxuICBmaWVsZERpcmVjdGl2ZXM6IEFycmF5PEdyYXBoUUxEaXJlY3RpdmU+LFxuICBzY2hlbWE6IEdyYXBoUUxTY2hlbWEsXG4gIGNvbnRleHQ6IHVua25vd25cbikgPT4gdm9pZFxuXG4vLyBDcmVhdGUgY29uc3RhbnRzIGZvciBlYWNoIG9mIHRoZSB0eXBlcyBhbGxvd2VkLCBvdmVyIHdoaWNoIG9uZSBtaWdodFxuLy8gaXRlcmF0ZS4gVGhlc2UgY2FuIGJlIGJpdG1hc2tlZCB0byBpbmNsdWRlIG11bHRpcGxlIHR5cGVzOyBpLmUuIGZvciBib3RoXG4vLyB0eXBlIGFuZCBlbnVtcywgcGFzcyBUWVBFUyB8IEVOVU1TIGZvciB0aGUgdHlwZXMgcGFyYW1ldGVyLiBJdFxuLy8gZGVmYXVsdHMgdG8gc2ltcGx5IHR5cGVzLlxuY29uc3QgQUxMID0gMVxuY29uc3QgVFlQRVMgPSAyXG5jb25zdCBJTlRFUkZBQ0VTID0gNFxuY29uc3QgRU5VTVMgPSA4XG5jb25zdCBVTklPTlMgPSAxNlxuY29uc3QgU0NBTEFSUyA9IDMyXG5jb25zdCBST09UX1RZUEVTID0gNjRcbmNvbnN0IElOUFVUX1RZUEVTID0gMTI4XG5jb25zdCBISURERU4gPSAyNTZcbmNvbnN0IE1hc2tzID0gW1xuICBBTEwsIFRZUEVTLCBJTlRFUkZBQ0VTLCBVTklPTlMsIEVOVU1TLCBTQ0FMQVJTLFxuICBST09UX1RZUEVTLCBJTlBVVF9UWVBFU1xuXVxuZXhwb3J0IHR5cGUgQml0bWFza2VkVHlwZSA9XG4gIEFMTCB8IFRZUEVTIHwgSU5URVJGQUNFUyB8IEVOVU1TIHwgVU5JT05TIHwgU0NBTEFSUyB8IFJPT1RfVFlQRVMgfCBJTlBVVF9UWVBFUyB8IEhJRERFTlxuXG4vLyBDcmVhdGUgYSBtYXBwaW5nIGZyb20gdGhlIGNvbnN0YW50IHRvIHRoZSBHcmFwaFFMIHR5cGUgY2xhc3MuXG5jb25zdCBUeXBlTWFwOiBNYXA8bnVtYmVyLCBHcmFwaFFMVHlwZT4gPSBuZXcgTWFwKClcblR5cGVNYXAuc2V0KFRZUEVTLCBHcmFwaFFMT2JqZWN0VHlwZSlcblR5cGVNYXAuc2V0KFJPT1RfVFlQRVMsIEdyYXBoUUxPYmplY3RUeXBlKVxuVHlwZU1hcC5zZXQoSU5URVJGQUNFUywgR3JhcGhRTEludGVyZmFjZVR5cGUpXG5UeXBlTWFwLnNldChJTlBVVF9UWVBFUywgR3JhcGhRTElucHV0T2JqZWN0VHlwZSlcblR5cGVNYXAuc2V0KEVOVU1TLCBHcmFwaFFMRW51bVR5cGUpXG5UeXBlTWFwLnNldChVTklPTlMsIEdyYXBoUUxVbmlvblR5cGUpXG5UeXBlTWFwLnNldChTQ0FMQVJTLCBHcmFwaFFMU2NhbGFyVHlwZSlcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIHRoZSB2YWx1ZXMgY29udGFpbmVkIGluIGEgU2NoZW1hJ3MgdHlwZU1hcC4gSWYgYSBkZXNpcmVkXG4gKiB2YWx1ZSBpcyBlbmNvdW50ZXJlZCwgdGhlIHN1cHBsaWVkIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZC4gVGhlIHZhbHVlcyBhcmVcbiAqIHRoZSBjb25zdGFudHMgQUxMLCBUWVBFUywgSU5URVJGQUNFUywgRU5VTVMsIFVOSU9OUyBhbmQgU0NBTEFSUy4gT3B0aW9uYWxseVxuICogSElEREVOIGlzIGFub3RoZXIgdmFsdWUgdGhhdCBjYW4gYmUgYml0bWFza2VkIHRvZ2V0aGVyIGZvciBhIHZhcmllZCByZXN1bHQuXG4gKiBISURERU4gZXhwb3NlcyB0aGUgdmFsdWVzIGluIHRoZSBzY2hlbWEgdHlwZW1hcCB0aGF0IGJlZ2luIHdpdGggYSBkb3VibGVcbiAqIHVuZGVyc2NvcmUuXG4gKlxuICogVGhlIHNpZ25hdHVyZSBmb3IgdGhlIGZ1bmN0aW9uIGNhbGxiYWNrIGlzIGFzIGZvbGxvd3M6XG4gKiAoXG4gKiAgIHR5cGU6IHVua25vd24sXG4gKiAgIHR5cGVOYW1lOiBzdHJpbmcsXG4gKiAgIHR5cGVEaXJlY3RpdmVzOiBBcnJheTxHcmFwaFFMRGlyZWN0aXZlPlxuICogICBzY2hlbWE6IEdyYXBoUUxTY2hlbWEsXG4gKiAgIGNvbnRleHQ6IHVua25vd24sXG4gKiApID0+IHZvaWRcbiAqXG4gKiBXaGVyZTpcbiAqICAgYHR5cGVgICAgICAgICAgICAtIHRoZSBvYmplY3QgaW5zdGFuY2UgZnJvbSB3aXRoaW4gdGhlIGBHcmFwaFFMU2NoZW1hYFxuICogICBgdHlwZU5hbWVgICAgICAgIC0gdGhlIG5hbWUgb2YgdGhlIG9iamVjdDsgXCJRdWVyeVwiIGZvciB0eXBlIFF1ZXJ5IGFuZFxuICogICAgICAgICAgICAgICAgICAgICAgc28gb24uXG4gKiAgIGB0eXBlRGlyZWN0aXZlc2AgLSBhbiBhcnJheSBvZiBkaXJlY3RpdmVzIGFwcGxpZWQgdG8gdGhlIG9iamVjdCBvciBhblxuICogICAgICAgICAgICAgICAgICAgICAgZW1wdHkgYXJyYXkgaWYgdGhlcmUgYXJlIG5vbmUgYXBwbGllZC5cbiAqICAgYHNjaGVtYWAgICAgICAgICAtIGFuIGluc3RhbmNlIG9mIGBHcmFwaFFMU2NoZW1hYCBvdmVyIHdoaWNoIHRvIGl0ZXJhdGVcbiAqICAgYGNvbnRleHRgICAgICAgICAtIHVzdWFsbHkgYW4gb2JqZWN0LCBhbmQgdXN1YWxseSB0aGUgc2FtZSBvYmplY3QsXG4gKiAgICAgICAgICAgICAgICAgICAgICBwYXNzZWQgdG8gdGhlIGNhbGwgdG8gYG1ha2VFeGVjdXRhYmxlU2NoZW1hKClgXG4gKiAgICAgICAgICAgICAgICAgICAgICBvciBgZ3JhcGhxbCgpYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIGEgZnVuY3Rpb24gd2l0aCBhIHNpZ25hdHVyZSBkZWZpbmVkIGFib3ZlXG4gKiBAcGFyYW0ge21peGVkfSBjb250ZXh0IHVzdWFsbHkgYW4gb2JqZWN0IGJ1dCBhbnkgbWl4ZWQgdmFsdWUgdGhlIGRlbm90ZXNcbiAqIHNvbWUgc2hhcmVkIGNvbnRleHQgYXMgaXMgdXNlZCB3aXRoIHRoZSBzY2hlbWEgZHVyaW5nIG5vcm1hbCBydW50aW1lLlxuICogQHBhcmFtIHtOdW1iZXJ9IHR5cGVzIGEgYml0bWFzayBvZiBvbmUgb3IgbW9yZSBvZiB0aGUgY29uc3RhbnRzIGRlZmluZWRcbiAqIGFib3ZlLiBUaGVzZSBjYW4gYmUgT1InZWQgdG9nZXRoZXIgYW5kIGRlZmF1bHQgdG8gVFlQRVMuXG4gKiBAcmV0dXJuIHtHcmFwaFFMU2NoZW1hfSBhIG5ldyBzY2hlbWEgaXMgZ2VuZXJhdGVkIGZyb20gdGhpcyBTREwsIGl0ZXJhdGVkXG4gKiBvdmVyIGFuZCByZXR1cm5lZC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaE9mKFxuICBzY2hlbWE6IEdyYXBoUUxTY2hlbWEsXG4gIGZuOiBGb3JFYWNoT2ZSZXNvbHZlcixcbiAgY29udGV4dDogdW5rbm93bixcbiAgdHlwZXM6IG51bWJlciA9IEFMTFxuKTogR3JhcGhRTFNjaGVtYSB7XG4gIFtcbiAgICBHcmFwaFFMT2JqZWN0VHlwZSwgR3JhcGhRTEludGVyZmFjZVR5cGUsIEdyYXBoUUxFbnVtVHlwZSxcbiAgICBHcmFwaFFMVW5pb25UeXBlLCBHcmFwaFFMU2NhbGFyVHlwZVxuICBdLmZvckVhY2godCA9PiB7XG4gICAgaWYgKCF0KSByZXR1cm47XG5cbiAgICBpZiAoXG4gICAgICAhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0LnByb3RvdHlwZSkuaW5jbHVkZXMoU3ltYm9sLnRvU3RyaW5nVGFnKVxuICAgICkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModC5wcm90b3R5cGUsIHtcbiAgICAgICAgW1N5bWJvbC50b1N0cmluZ1RhZ106IHsgZ2V0KCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lIH0gfVxuICAgICAgfSlcbiAgICB9XG4gIH0pXG5cbiAgY29uc3QgdHlwZU1hcCA9IHNjaGVtYS5nZXRUeXBlTWFwKCk7XG5cbiAgT2JqZWN0LmtleXModHlwZU1hcCkuZm9yRWFjaCh0eXBlTmFtZSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IHR5cGVNYXBbdHlwZU5hbWVdO1xuICAgIGNvbnN0IGhpZGRlbiA9IGdldE5hbWVkVHlwZSh0eXBlKS5uYW1lLnN0YXJ0c1dpdGgoJ19fJylcbiAgICBjb25zdCBzaG93SGlkZGVuID0gKHR5cGVzICYgSElEREVOKSA9PT0gSElEREVOXG4gICAgY29uc3QgZGlyZWN0aXZlcyA9IHR5cGUgJiYgdHlwZS5hc3ROb2RlICYmIHR5cGUuYXN0Tm9kZS5kaXJlY3RpdmVzIHx8IFtdXG4gICAgbGV0IGRvSXQgPSAodHlwZXMgJiBBTEwpID09PSBBTExcblxuICAgIE1hc2tzLmZvckVhY2gobWFzayA9PiB7XG4gICAgICBpZiAoZG9JdCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKFxuICAgICAgICAobWFzayAmIFJPT1RfVFlQRVMpID09PSBST09UX1RZUEVTXG4gICAgICAgICYmXG4gICAgICAgIChcbiAgICAgICAgICB0eXBlID09PSBzY2hlbWEuZ2V0UXVlcnlUeXBlKClcbiAgICAgICAgICB8fCB0eXBlID09PSBzY2hlbWEuZ2V0U3Vic2NyaXB0aW9uVHlwZSgpXG4gICAgICAgICAgfHwgdHlwZSA9PT0gc2NoZW1hLmdldE11dGF0aW9uVHlwZSgpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBkb0l0ID0gdHJ1ZVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkb0l0ID1cbiAgICAgICAgICAoKHR5cGVzICYgbWFzaykgPT09IG1hc2spICYmXG4gICAgICAgICAgdHlwZSBpbnN0YW5jZW9mIFR5cGVNYXAuZ2V0KG1hc2spXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFByZXZlbnQgaGlkZGVuIGl0ZW1zIGZyb20gYmVpbmcgc2hvd24gdW5sZXNzIGFza2VkIGZvclxuICAgIGRvSXQgPSBkb0l0ICYmICghaGlkZGVuIHx8IChoaWRkZW4gJiYgc2hvd0hpZGRlbikpXG5cbiAgICBpZiAoZG9JdClcbiAgICAgIGZuKHR5cGUsIHR5cGVOYW1lLCBkaXJlY3RpdmVzLCBzY2hlbWEsIGNvbnRleHQpXG4gIH0pO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiBvZiBgZm9yRWFjaE9mYCB0aGF0IHRhcmdldHMgdGhlIGZpZWxkcyBvZiB0aGUgdHlwZXMgaW4gdGhlXG4gKiBzY2hlbWEncyB0eXBlTWFwLiBUaGlzIGZ1bmN0aW9uIHByb3ZpZGVzIG1vcmUgZGV0YWlsIGFuZCBhbGxvd3MgZ3JlYXRlclxuICogYWNjZXNzIHRvIGFueSBhc3NvY2lhdGVkIGBjb250ZXh0YCB0aGFuIHRoZSBmdW5jdGlvbiBvZiB0aGUgc2FtZSBuYW1lXG4gKiBwcm92aWRlZCBieSB0aGUgYGdyYXBocWwtdG9vbHNgIGxpYnJhcnkuXG4gKlxuICogVGhlIHNpZ25hdHVyZSBmb3IgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGFzIGZvbGxvd3NcbiAqXG4gKiAoXG4gKiAgIHR5cGU6IHVua25vd24sXG4gKiAgIHR5cGVOYW1lOiBzdHJpbmcsXG4gKiAgIHR5cGVEaXJlY3RpdmVzOiBBcnJheTxHcmFwaFFMRGlyZWN0aXZlPixcbiAqICAgZmllbGQ6IHVua25vd24sXG4gKiAgIGZpZWxkTmFtZTogc3RyaW5nLFxuICogICBmaWVsZEFyZ3M6IEFycmF5PEdyYXBoUUxBcmd1bWVudD4sXG4gKiAgIGZpZWxkRGlyZWN0aXZlczogQXJyYXk8R3JhcGhRTERpcmVjdGl2ZT4sXG4gKiAgIHNjaGVtYTogR3JhcGhRTFNjaGVtYSxcbiAqICAgY29udGV4dDogdW5rbm93blxuICogKSA9PiB2b2lkXG4gKlxuICogV2hlcmVcbiAqXG4gKiBXaGVyZTpcbiAqICAgYHR5cGVgICAgICAgICAgICAtIHRoZSBvYmplY3QgaW5zdGFuY2UgZnJvbSB3aXRoaW4gdGhlIGBHcmFwaFFMU2NoZW1hYFxuICogICBgdHlwZU5hbWVgICAgICAgIC0gdGhlIG5hbWUgb2YgdGhlIG9iamVjdDsgXCJRdWVyeVwiIGZvciB0eXBlIFF1ZXJ5IGFuZCBzbyBvblxuICogICBgdHlwZURpcmVjdGl2ZXNgIC0gYW4gYXJyYXkgb2YgZGlyZWN0aXZlcyBhcHBsaWVkIHRvIHRoZSBvYmplY3Qgb3IgYW4gZW1wdHlcbiAqICAgICAgICAgICAgICAgICAgICAgIGFycmF5IGlmIHRoZXJlIGFyZSBub25lIGFwcGxpZWQuXG4gKiAgIGBmaWVsZGAgICAgICAgICAgLSB0aGUgZmllbGQgaW4gcXVlc3Rpb24gZnJvbSB0aGUgdHlwZVxuICogICBgZmllbGROYW1lYCAgICAgIC0gdGhlIG5hbWUgb2YgdGhlIGZpZWxkIGFzIGEgc3RyaW5nXG4gKiAgIGBmaWVsZEFyZ3NgICAgICAgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMgZm9yIHRoZSBmaWVsZCBpbiBxdWVzdGlvblxuICogICBgZmllbGREaXJlY3RpdmVzYC0gYW4gYXJyYXkgb2YgZGlyZWN0aXZlcyBhcHBsaWVkIHRvIHRoZSBmaWVsZCBvciBhbiBlbXB0eVxuICogICAgICAgICAgICAgICAgICAgICAgYXJyYXkgc2hvdWxkIHRoZXJlIGJlIG5vIGFwcGxpZWQgZGlyZWN0aXZlc1xuICogICBgc2NoZW1hYCAgICAgICAgIC0gYW4gaW5zdGFuY2Ugb2YgYEdyYXBoUUxTY2hlbWFgIG92ZXIgd2hpY2ggdG8gaXRlcmF0ZVxuICogICBgY29udGV4dGAgICAgICAgIC0gdXN1YWxseSBhbiBvYmplY3QsIGFuZCB1c3VhbGx5IHRoZSBzYW1lIG9iamVjdCwgcGFzc2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICB0byB0aGUgY2FsbCB0byBgbWFrZUV4ZWN1dGFibGVTY2hlbWEoKWAgb3IgYGdyYXBocWwoKWBcbiAqXG4gKiBAcGFyYW0ge0dyYXBoUUxTY2hlbWF9IHNjaGVtYVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gYSBmdW5jdGlvbiB3aXRoIGEgc2lnbmF0dXJlIGRlZmluZWQgYWJvdmVcbiAqIEBwYXJhbSB7bWl4ZWR9IGNvbnRleHQgdXN1YWxseSBhbiBvYmplY3QgYnV0IGFueSBtaXhlZCB2YWx1ZSB0aGUgZGVub3Rlc1xuICogc29tZSBzaGFyZWQgY29udGV4dCBhcyBpcyB1c2VkIHdpdGggdGhlIHNjaGVtYSBkdXJpbmcgbm9ybWFsIHJ1bnRpbWUuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hGaWVsZChcbiAgc2NoZW1hOiBHcmFwaFFMU2NoZW1hLFxuICBmbjogRm9yRWFjaEZpZWxkUmVzb2x2ZXIsXG4gIGNvbnRleHQ6IHVua25vd24sXG4gIHR5cGVzOiBudW1iZXIgPSBBTExcbik6IEdyYXBoUUxTY2hlbWEge1xuICBmb3JFYWNoT2YoXG4gICAgc2NoZW1hLFxuICAgICh0eXBlLCB0eXBlTmFtZSwgXywgY29udGV4dCwgZGlyZWN0aXZlcykgPT4ge1xuICAgICAgaWYgKCF0eXBlLl9maWVsZHMpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5rZXlzKHR5cGUuX2ZpZWxkcykuZm9yRWFjaChmaWVsZE5hbWUgPT4ge1xuICAgICAgICBsZXQgZmllbGQgPSB0eXBlLl9maWVsZHNbZmllbGROYW1lXVxuICAgICAgICBsZXQgZmllbGREaXJlY3RpdmVzID0gZmllbGQuYXN0Tm9kZSAmJiBmaWVsZC5hc3ROb2RlLmRpcmVjdGl2ZXMgfHwgW11cbiAgICAgICAgbGV0IGZpZWxkQXJncyA9IGZpZWxkLmFyZ3MgfHwgW11cblxuICAgICAgICBmbihcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIHR5cGVOYW1lLFxuICAgICAgICAgIGRpcmVjdGl2ZXMsXG4gICAgICAgICAgZmllbGQsXG4gICAgICAgICAgZmllbGROYW1lLFxuICAgICAgICAgIGZpZWxkQXJncyxcbiAgICAgICAgICBmaWVsZERpcmVjdGl2ZXMsXG4gICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9LFxuICAgIGNvbnRleHQsXG4gICAgdHlwZXNcbiAgKVxufVxuXG5leHBvcnQge1xuICBBTEwsXG4gIFRZUEVTLFxuICBJTlRFUkZBQ0VTLFxuICBFTlVNUyxcbiAgVU5JT05TLFxuICBTQ0FMQVJTLFxuICBST09UX1RZUEVTLFxuICBJTlBVVF9UWVBFUyxcbiAgSElEREVOLFxuXG4gIFR5cGVNYXAsXG5cbiAgZm9yRWFjaE9mLFxuICBmb3JFYWNoRmllbGRcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9yRWFjaE9mXG4iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBRUEsSUFBQUEsUUFBQSxHQUFBQyxPQUFBO0FBRkE7O0FBa0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsR0FBRyxHQUFBQyxPQUFBLENBQUFELEdBQUEsR0FBRyxDQUFDO0FBQ2IsTUFBTUUsS0FBSyxHQUFBRCxPQUFBLENBQUFDLEtBQUEsR0FBRyxDQUFDO0FBQ2YsTUFBTUMsVUFBVSxHQUFBRixPQUFBLENBQUFFLFVBQUEsR0FBRyxDQUFDO0FBQ3BCLE1BQU1DLEtBQUssR0FBQUgsT0FBQSxDQUFBRyxLQUFBLEdBQUcsQ0FBQztBQUNmLE1BQU1DLE1BQU0sR0FBQUosT0FBQSxDQUFBSSxNQUFBLEdBQUcs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
//# sourceMappingURL=forEachOf.js.map