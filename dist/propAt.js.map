{"version":3,"file":"propAt.js","names":["_errors","require","DoNotSet","exports","Symbol","for","at","object","path","setTo","playNice","undefined","TypeError","includes","split","target","i","length","key","InvalidPathError","slice","join","lastKey","Reflect","has","atNicely","_default","default"],"sources":["../src/propAt.js"],"sourcesContent":["// @ts-check\n\nimport { InvalidPathError } from './errors'\n\nexport const DoNotSet = Symbol.for('DoNotSet')\n\n/**\n * This function takes an array of values that are used with `eval` to\n * dynamically, and programmatically, access the value of an object in a nested\n * fashion. It can take either a string with values separated by periods\n * (including array indices as numbers) or an array equivalent were\n * `.split('.')` to have been called on said string.\n *\n * Examples:\n * ```\n *   // Calling `at` with either set of arguments below results in the same\n *   // values.\n *   let object = { cats: [{ name: 'Sally' }, { name: 'Rose' }] }\n *\n *   at(object, 'cats.1.name') => Rose\n *   at(object, ['cats', 1, 'name']) => Rose\n *\n *   // Values can be altered using the same notation\n *   at(object, 'cats.1.name', 'Brie') => Brie\n *\n *   // Values cannot normally be accessed beyond existence. The following\n *   // will throw an error. A message to console.error will be written showing\n *   // the attempted path before the error is again rethrown\n *   at(object, 'I.do.not.exist') => ERROR\n *\n *   // However, if you want the function to play nice, `undefined` can be\n *   // returned instead of throwing an error if true is specified as the\n *   // fourth parameter\n *   at(object, 'I.do.not.exist', undefined, true) => undefined\n * ```\n *\n * @method at\n *\n * @param {Object} object an object that can be accessed using bracket notation\n * to access its inner property value. Anything extending object, including\n * arrays and functions, should work in this manner.\n * @param {string|string[]} path a period denoted path (numeric indicies\n * are allowed) or an array of individual strings. See above for more details\n * @param {unknown} setTo (optional) if this value is supplied, the path accessed\n * will be modified to this value before it is returned\n * @param {boolean} playNice (optional) by default if one tries to access a\n * path that fails somewhere in the middle and results in accessing a property\n * on an undefined or null value then an exception is thrown. Passing true here\n * will cause the function to simply return undefined.\n * @return {unknown} either the requested value or undefined as long as no\n * invalid access was requested. Otherwise an error is thrown if try to deeply\n * reach into a space where no value exists.\n */\nexport function at(\n  object: Object,\n  path: string | string[],\n  setTo?: unknown = DoNotSet,\n  playNice?: boolean = false\n): unknown {\n  if (typeof object !== 'object' || object === null || object === undefined) {\n    throw new TypeError(`The first argument must be an object`)\n  }\n\n  if (typeof path === 'string') {\n    if (path.includes('.')) {\n      path = path.split('.')\n    }\n    else {\n      path = [path]\n    }\n  }\n\n  let target = object;\n\n  // Iterate through the path, except the last key\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n    if (key in target) {\n      target = target[key];\n    } else if (playNice) {\n      return undefined;\n    } else {\n      throw new InvalidPathError(`Invalid path: ${path.slice(0, i + 1).join('.')}`);\n    }\n  }\n\n  const lastKey = path[path.length - 1];\n\n  // Handle setTo, if provided\n  if (setTo !== DoNotSet) {\n    // Ensure the path is valid before setting the value\n    if (!(Reflect.has(target, lastKey)) && !playNice) {\n      throw new InvalidPathError(`Invalid path: ${path.join('.')}`);\n    }\n    target[lastKey] = setTo;\n  }\n\n  if (!Reflect.has(target, lastKey) && !playNice) {\n    throw new InvalidPathError(`Invalid path: ${path.join('.')}`)\n  }\n\n  // Return the value at the specified path, or undefined if playNice is true and the path is invalid\n  return Reflect.has(target, lastKey)\n    ? target[lastKey]\n    : undefined\n}\n\n/**\n * `atNicely()` is a shorthand version of calling `at()` but specifying `true`\n * for the argument `playNice`. This can make reads normally performed with\n * calls to `at()` where you want to prevent errors from being thrown with\n * invalid paths\n *\n * @method atNicely\n *\n * @param {Object} object an object that can be accessed using bracket notation\n * to access its inner property value. Anything extending object, including\n * arrays and functions, should work in this manner.\n * @param {string|string[]} path a period denoted path (numeric indicies\n * are allowed) or an array of individual strings. See above for more details\n * @param {unknown} setTo (optional) if this value is supplied, the path accessed\n * will be modified to this value before it is returned\n * @return {unknown} either the requested value or undefined\n */\nexport function atNicely(\n  object: Object,\n  path: string | string[],\n  setTo?: unknown\n): unknown {\n  return at(object, path, setTo, true)\n}\n\n/**\n * Default export is atNicely; as long as you know what you want, this leaves\n * cleaner code in your repository. Simply add this to the top of your module\n * ```\n * const at = require('./propAt').default\n * // or\n * import at from './propAt'\n *\n * // of course if you prefer, you may still do the following\n * const at = require('./propAt').at;\n * // or\n * import { at } from './propAt'\n * ```\n */\nexport default atNicely\n"],"mappings":"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","ignoreList":[]}