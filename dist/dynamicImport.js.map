{"version":3,"file":"dynamicImport.js","names":["_promises","require","_path","_module","_TypeScriptFlagMissingError","_InvalidPathError","_GraphQLExtension","_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","supportsNativeTypeScript","node_opts","process","env","NODE_OPTIONS","split","execArgv","includes","fileExists","pathToFile","mustNotBeDirectory","stats","stat","isDirectory","ignore","findNearestPackageJson","startDir","cwd","dir","parse","root","potentialPath","join","access","resolve","error","dirname","guessProjectRoot","useIfNotFound","nearestPackageJson","dynamicImport","modulePath","errorOnMissing","packageJsonPath","__dirname","parsedPath","pathParse","StandardTSExtensions","ext","TypeScriptFlagMissingError","InvalidPathError","specifier","Promise","then","s","Module","exports","path","fullPath","baseParsed","pathStat","base","isDir"],"sources":["../src/dynamicImport.js"],"sourcesContent":["import { access, readFile, stat } from 'fs/promises'\nimport { dirname, join, parse, resolve } from 'path'\nimport { Module } from 'module'\n\nimport { TypeScriptFlagMissingError } from './errors/TypeScriptFlagMissingError';\nimport { InvalidPathError } from './errors/InvalidPathError';\nimport { StandardTSExtensions } from './GraphQLExtension';\n\n/**\n * Combines any environmental NODE_OPTIONS and execArgv parameters and checks\n * for the existence of the new TypeScript stripping flags or if the process\n * is running through `tsx` or `ts-node` wrappers. If any of these things are\n * true, then dynamically import()'ing a .ts/.tsx file is likely to succedd.\n *\n * @returns {boolean} true if sufficient runtime TypeScript loading support\n * is present and available; false otherwise\n */\nexport function supportsNativeTypeScript() {\n  const node_opts = [\n    ...((process.env?.NODE_OPTIONS ?? '').split(' ')),\n    ...process.execArgv,\n  ]\n\n  return (\n    node_opts.includes('--experimental-transform-types') ||\n    node_opts.includes('--experimental-strip-types') ||\n    node_opts.includes('node_modules/tsx') ||\n    node_opts.includes('node_modules/ts-node')\n  )\n}\n\n/**\n *\n * @param {string} pathToFile string path to where, hopefully, a file might\n * exist.\n * @param {boolean} [mustNotBeDirectory=true] a flag to indicate that false\n * should be returned if the file is a directory, even if it does exist on\n * the file system. This behavior defaults to true.\n * @returns {Promise<boolean>} true if a file exists (see mustNotBeDirectory),\n * and false otherwise\n */\nexport async function fileExists(pathToFile, mustNotBeDirectory = true) {\n  try {\n    const stats = await stat(pathToFile)\n\n    // We only make it here if the result of calling stat() did not throw an\n    // error. If isDirectory() is true and mustNotBeDirectory, then we return\n    // the opposite of true which is false.\n    return mustNotBeDirectory ? !stats.isDirectory() : true;\n  }\n  catch (ignore) {\n    return false\n  }\n}\n\n/**\n * Searches for the nearest package.json file by walking up the directory tree.\n *\n * @param {string} startDir - The directory to start the search from. If this\n * is a falsy value, `process.cwd()` is used instead.\n * @returns {Promise<string|null>} - A promise that resolves to the path to the\n * nearest package.json, or null if not found.\n */\nexport async function findNearestPackageJson(startDir) {\n  if (!startDir)\n    startDir = process.cwd()\n\n  let dir = startDir;\n\n  while (dir !== parse(dir).root) {\n    const potentialPath = join(dir, 'package.json');\n\n    try {\n      await access(potentialPath);\n      return resolve(potentialPath);\n    } catch (error) {\n      dir = dirname(dir);\n    }\n  }\n\n  return null;\n}\n\n/**\n * Searches for the nearest package.json file by walking up the directory tree.\n * If a package json file is found, the path to that file is assumed to be the\n * root directory.\n *\n * @param {string} startDir - The directory to start the search from. If this\n * is a falsy value, `process.cwd()` is used instead.\n * @param {string?} useIfNotFound - An optional string, defaults to undefined,\n * that will be substituted if not package.json file was found while walking\n * up the directory tree.\n * @returns {Promise<string>} - A promise that resolves to the path to the\n * nearest package.json, or the value of `useIfNotFound` which defaults to\n * undefined.\n */\nexport async function guessProjectRoot(startDir, useIfNotFound) {\n  const nearestPackageJson = await findNearestPackageJson(startDir)\n\n  if (nearestPackageJson) {\n    // if undefined or an empty string, default to useIfNotFound or undefined\n    return parse(nearestPackageJson)?.dir || useIfNotFound\n  }\n\n  return useIfNotFound\n}\n\n/**\n * Attempts to use `await import()` to grab the JavaScript module content from\n * the specified file dynamically. If this fails, an empty Module exports object\n * is returned.\n *\n * @note files that end in known TypeScript file extensions will cause an error\n * to be thrown if native typescript support is not available. See this function\n * {@link supportsNativeTypeScript} for more information.\n *\n * @param {string} modulePath - The path to the module to be imported.\n * @param {boolean?} [errorOnMissing=true] - if false, and the file at\n * modulePath does not exist, return an empty Module's exports. Defaults to true\n * @returns {Promise<object>} - A promise that resolves to the imported module.\n *\n * @throws {TypeScriptFlagMissingError} if the appropriate measures haven't been\n * taken to allow for dynamic runtime TypeScript import support.\n */\nexport async function dynamicImport(modulePath, errorOnMissing = true) {\n  const packageJsonPath = await findNearestPackageJson(__dirname);\n  const parsedPath = pathParse(modulePath)\n\n  if (\n    !supportsNativeTypeScript() &&\n    StandardTSExtensions.includes(parsedPath.ext)\n  ) {\n    throw new TypeScriptFlagMissingError(modulePath)\n  }\n\n  if (!fileExists(modulePath, false)) {\n    throw new InvalidPathError(modulePath, `Cannot import ${modulePath}; missing`)\n  }\n\n  try {\n    return await import(modulePath)\n  }\n  catch (ignore) {\n    return new Module().exports\n  }\n}\n\n/**\n * Asynchronously parses a given file or directory path to provide detailed path information along with\n * the resolved full path and a directory indicator.\n *\n * This function receives a single string argument representing a file or directory path, which it\n * subsequently resolves to an absolute path using Node.js's `path.resolve`. It then parses the\n * resolved path using `path.parse` to extract path components such as the root, directory, base,\n * extension, and name. Additionally, it performs a filesystem stat operation on the resolved path\n * using `fs.promises.stat` to determine whether the path represents a directory. The function\n * amalgamates these pieces of information into a single object, which it returns.\n *\n * The returned object extends the object returned by `path.parse` with three additional properties:\n * - `base`: Overridden to an empty string.\n * - `fullPath`: The absolute, resolved path.\n * - `isDir`: A boolean indicating whether the path represents a directory.\n *\n * This function is asynchronous and returns a promise that resolves to the aforementioned object.\n *\n * @param {string} path - The file or directory path to be parsed. Accepts both relative and absolute paths.\n * @returns {Promise<Object>} A promise that resolves to an object encapsulating detailed path information,\n * the resolved full path, and a directory indicator.\n * @throws Will throw an error if the filesystem stat operation fails, for instance due to insufficient\n * permissions or a nonexistent path.\n *\n * @example\n * pathParse('./someDir')\n *   .then(info => console.log(info))\n *   .catch(error => console.error('An error occurred:', error));\n */\nexport async function pathParse(path) {\n  const fullPath = resolve(path)\n  const baseParsed = parse(fullPath)\n  const pathStat = await stat(fullPath)\n\n  return { ...baseParsed, ...{base: '', fullPath, isDir: pathStat.isDirectory() } }\n}\n"],"mappings":"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","ignoreList":[]}