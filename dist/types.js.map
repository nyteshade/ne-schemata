{"version":3,"file":"types.js","names":["_graphql","require"],"sources":["../src/types.js"],"sourcesContent":["// @ts-check\n\nimport type { Schemata } from './Schemata'\nimport { Source, GraphQLSchema, ASTNode } from 'graphql'\n\n/**\n * The ResolverInfo type declares the properties that will likely\n * need to be applied to schema after the executableSchema has\n * been created. This needs to be expanded to also include handlers\n * for directives and custom scalars.\n *\n * @type {ResolverInfo}\n */\nexport type ResolverInfo = {\n  type: string,\n  resolveType?: (obj, contextValue, info) => string,\n  isTypeOf?: (obj, context, info) => boolean,\n  description?: () => string,\n  fieldDescriptions?: { string: () => string|string },\n  applyTo: (schema: GraphQLSchema, overwrite?: boolean) => void\n}\n\n/**\n * An object that specifies the various types of resolvers that might occur\n * during a given conflict resolution\n */\nexport type ConflictResolvers = {\n  /** A handler for resolving fields in matching types */\n  fieldMergeResolver?: FieldMergeResolver,\n\n  /** A handler for resolving directives in matching types */\n  directiveMergeResolver?: DirectiveMergeResolver,\n\n  /** A handler for resolving conflicting enum values */\n  enumValueMergeResolver?: EnumMergeResolver,\n\n  /** A handler for resolving type values in unions */\n  typeValueMergeResolver?: UnionMergeResolver,\n\n  /** A handler for resolving scalar config conflicts in custom scalars */\n  scalarMergeResolver?: ScalarMergeResolver\n}\n\n/**\n * The callback for collision when a directive is trying to be merged with an\n * existing directive.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's directive from the right\n * @param {DirectiveNode} leftDirective the DirectiveNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the directive to be merged\n * @param {DirectiveNode} rightDirective the DirectiveNode requesting to be\n * merged and finding a conflicting value already present\n * @return {DirectiveNode} the directive to merge into the existing schema\n * layout. To ignore changes, returning the leftDirective is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type DirectiveMergeResolver = (\n  leftType: ASTNode,\n  leftDirective: DirectiveNode,\n  rightType: ASTNode,\n  rightDirective: DirectiveNode\n) => DirectiveNode\n\n/**\n * The callback for collision when a enum value is trying to be merged with an\n * existing enum value of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's enum value from the right\n * @param {EnumValueNode} leftValue the EnumValueNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the enum value to be\n * merged\n * @param {EnumValueNode} rightValue the EnumValueNode requesting to be\n * merged and finding a conflicting value already present\n * @return {EnumValueNode} the enum value to merge into the existing schema\n * layout. To ignore changes, returning the leftValue is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type EnumMergeResolver = (\n  leftType: ASTNode,\n  leftValue: EnumValueNode,\n  rightType: ASTNode,\n  rightValue: EnumValueNode\n) => EnumValueNode\n\n/**\n * The callback for collision when a field is trying to be merged with an\n * existing field.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's field from the right\n * @param {FieldNode} leftField the FieldNode denoting the value that should\n * be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the field to be merged\n * @param {FieldNode} rightField the FieldNode requesting to be merged and\n * finding a conflicting value already present\n * @return {FieldNode} the field to merge into the existing schema layout. To\n * ignore changes, returning the leftField is sufficient enough. The default\n * behavior is to always take the right hand value, overwriting new with old\n */\nexport type FieldMergeResolver = (\n  leftType: ASTNode,\n  leftField: FieldNode,\n  rightType: ASTNode,\n  rightField: FieldNode\n) => FieldNode\n\n/**\n * A flow type definition of an object containing one or more resolver\n * injector functions.\n *\n * The `.resolverInjectors` property is an array of `ResolverArgsTransformer`\n * functions that allow you to modify the arguments being sent to the resolvers\n * in question.\n *\n * If `.injectMergedSchema` is true, all existing resolvers will be wrapped\n * with an instance of `ExtendedResolver` that injects a reference to the newly\n * merged GraphQLSchema rather than any previously set elsewhere.\n *\n * If `.createMissingResolvers` is true, every field that doesn't have a\n * resolver will be assigned the `defaultFieldResolver` before the injection of\n * any newly merged schema occurs.\n *\n * @see ResolverArgsTransformer\n * @type {MergeOptionsConfig}\n */\nexport type MergeOptionsConfig = {\n  conflictResolvers: ConflictResolvers,\n  resolverInjectors: ResolverArgsTransformer | Array<ResolverArgsTransformer>,\n  injectMergedSchema: boolean,\n  createMissingResolvers: boolean\n}\n\n/**\n * To complete the ResolverMap type, we define a string key mapped to either\n * a function or a nested `ResolverMap`.\n *\n * @type {ResolverMap}\n */\nexport type ResolverMap = { [string]: Function | ResolverMap }\n\n/**\n * All resolvers are passed four parameters. This object contains all four\n * of those parameters.\n *\n * @type {ResolverArgs}\n */\nexport type ResolverArgs = {\n  source: unknown,\n  args: unknown,\n  context: unknown,\n  info: GraphQLResolveInfo\n}\n\n/**\n * A function that takes an option that conforms to `ResolverArgs`. The values\n * passed in must be passed back, or variations of the same type. The idea is\n * to allow the values to be modified, viewed or parsed before merged resolvers\n * are bound with these values.\n *\n * @param  {ResolverArgs} args an object with the four arguments passed to each\n * resolver so that they can be modified before used to wrap existing resolvers\n * after a merge.\n * @return {ResolverArgs} see above\n */\nexport type ResolverArgsTransformer = (args: ResolverArgs) => ResolverArgs\n\n/**\n * A callback for to resolve merge conflicts with custom scalar types defined\n * by the user.\n *\n * @param {ScalarTypeDefinitionNode} leftScalar the definition node found when\n * parsing ASTNodes. This is the existing value that conflicts with the to be\n * merged value\n * @param {GraphQLScalarTypeConfig} leftConfig *if* there is a resolver defined\n * for the existing ScalarTypeDefinitionNode it will be provided here. If this\n * value is null, there is no availabe config with serialize(), parseValue() or\n * parseLiteral() to work with.\n * @param {ScalarTypeDefinitionNode} rightScalar the definition node found when\n * parsing ASTNodes. This is to be merged value that conflicts with the\n * existing value\n * @param {GraphQLScalarTypeConfig} rightConfig *if* there is a resolver\n * defined for the existing ScalarTypeDefinitionNode it will be provided here.\n * If this value is null, there is no availabe config with serialize(),\n * parseValue() or parseLiteral() to work with.\n * @return {GraphQLScalarTypeConfig} whichever type config or resolver was\n * desired should be returned here.\n *\n * @see https://www.apollographql.com/docs/graphql-tools/scalars.html\n * @see http://graphql.org/graphql-js/type/#graphqlscalartype\n */\nexport type ScalarMergeResolver = (\n  leftScalar: ScalarTypeDefinitionNode,\n  leftConfig: GraphQLScalarTypeConfig,\n  rightScalar: ScalarTypeDefinitionNode,\n  rightConfig: GraphQLScalarTypeConfig\n) => GraphQLScalarTypeConfig\n\n/**\n * The callback for collision when a union type is trying to be merged with an\n * existing union type of the same name.\n *\n * @param {ASTNode} leftType the ASTNode, usually denoting a type, that will\n * receive the merged type's union type from the right\n * @param {NamedTypeNode} leftValue the NamedTypeNode denoting the value\n * that should be modified or replaced\n * @param {ASTNode} rightType the ASTNode containing the union type to be\n * merged\n * @param {NamedTypeNode} rightValue the NamedTypeNode requesting to be\n * merged and finding a conflicting value already present\n * @return {NamedTypeNode} the union type to merge into the existing schema\n * layout. To ignore changes, returning the leftUnion is sufficient enough.\n * The default behavior is to always take the right hand value, overwriting\n * new with old\n */\nexport type UnionMergeResolver = (\n  leftType: ASTNode,\n  leftUnion: NamedTypeNode,\n  rightType: ASTNode,\n  rightUnion: NamedTypeNode\n) => NamedTypeNode\n\n/**\n * A flow type that represents the various types of inputs that can often\n * be used to construct an instance of `Schemata`.\n *\n * @type {SchemaSource}\n */\nexport type SchemaSource = string\n  | Source\n  | Schemata\n  | GraphQLSchema\n  | ASTNodes;\n\n/**\n * A flow type defining the parameters for creating a new instance of\n * `ExtendedResolverMap`. At least the resolver map is required, but ideally\n * a `.schema` or `.sdl` value are desired\n *\n * @type {ExtendedResolverMapConfig}\n */\nexport type ExtendedResolverMapConfig = {\n  schema?: ?GraphQLSchema,\n  sdl?: string | Schemata,\n  resolvers: { [string]: string },\n}\n\n/**\n * A union of types representing either the ExtendedResolverMapConfig type or\n * an instance of Schemata.\n *\n * @type {SchemataConfigUnion}\n */\nexport type SchemataConfigUnion = ExtendedResolverMapConfig | Schemata\n\n/**\n * The ResolverResultsPatcher is an asynchronous function, or a function that\n * returns a promise, which receives the final value of all the extended\n * resolvers combined work as a parameter. The results of this function will\n * be the final value returned to the GraphQL engine.\n *\n * @type {AsyncFunction}\n */\nexport type ResolverResultsPatcher = (results: unknown) => Promise<mixed>\n\n/**\n * An `EntryInspector` is a function passed to `walkResolverMap` that is\n * invoked for each encountered pair along the way as it traverses the\n * `ResolverMap` in question. The default behavior is to simply return the\n * supplied entry back.\n *\n * If false, null or undefined is returned instead of an object with a string\n * mapping to a Function, then that property will not be included in the final\n * results of `walkResolverMap`.\n *\n * @type {Function}\n *\n * @param {{[string]: Function}} entry the key value pair supplied on each call\n * @param {[string]} path an array of strings indicating the path currently\n * being executed\n * @param {ResolverMap} map the map in question should it be needed\n */\nexport type EntryInspector = (\n  key: string,\n  value: Function,\n  path: Array<string>,\n  map: ResolverMap\n) => ?{ [string]: Function }\n\n/**\n * An `AsyncEntryInspector` is a function passed to `asyncWalkResolverMap`\n * that is invoked for each encountered pair along the way as it traverses the\n * `ResolverMap` in question. The default behavior is to simply return the\n * supplied entry back.\n *\n * If false, null or undefined is returned instead of an object with a string\n * mapping to a Function, then that property will not be included in the final\n * results of `asyncWalkResolverMap`.\n *\n * @type {Function}\n *\n * @param {{[string]: Function}} entry the key value pair supplied on each call\n * @param {[string]} path an array of strings indicating the path currently\n * being executed\n * @param {ResolverMap} map the map in question should it be needed\n */\nexport type AsyncEntryInspector = (\n  key: string,\n  value: Function,\n  path: Array<string>,\n  map: ResolverMap\n) => ?Promise<{ [string]: Function }>\n"],"mappings":";;AAGA,IAAAA,QAAA,GAAAC,OAAA","ignoreList":[]}