{"version":3,"file":"walkResolverMap.js","names":["_errors","require","_typework","_propAt","_interopRequireDefault","e","__esModule","default","DefaultEntryInspector","key","value","path","map","exports","DefaultAsyncEntryInspector","walkResolverMap","object","inspector","wrap","product","reduce","prev","cur","at","concat","push","Object","entries","isObject","isFunction","isFn","newPath","ResolverMapStumble","Error","join","entry","undefined","asyncWalkResolverMap","skips","stumble","Array","isArray","source","destination","mergeResolvers","existingResolvers","newResolvers","conflictResolver","walkAndMerge","current","incoming","keys","Reflect","has","existingValue","incomingValue","existingProp","name","incomingProp","_default"],"sources":["../src/walkResolverMap.js"],"sourcesContent":["// @ts-check\n\nimport type { ResolverMap, EntryInspector, AsyncEntryInspector } from './types'\nimport { ResolverMapStumble } from './errors'\nimport { isFn, getType } from './utils/typework'\nimport at from './propAt'\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `walkResolverMap`. While not immediately useful, a default implementation\n * causes `walkResolverMap` to wrap any non-function and non-object values\n * with a function that returns the non-compliant value and therefore has some\n * intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {EntryInspector}\n */\nexport const DefaultEntryInspector = (key, value, path, map) => {\n  return { [key]: value }\n}\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `asyncWalkResolverMap`. While not immediately useful, a default\n * implementation causes `asyncWalkResolverMap` to wrap any non-function and\n * non-object values with a function that returns the non-compliant value and\n * therefore has some intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {AsyncEntryInspector}\n */\nexport const DefaultAsyncEntryInspector = async (key, value, path, map) => {\n  return { [key]: value }\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method walkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {EntryInspector} [inspector=DefaultEntryInspector] the inspector that\n * is used to walk the file\n * @param {boolean} [wrap=true] defaults to true. An entry whose value is\n * neither a function nor an object will be wrapped in a function returning\n * the value. If false is supplied here, a `ResolverMapStumble` error will\n * be thrown instead\n * @param {string[]} path as `walkResolverMap` calls itself recursively,\n * path is appended to and added as a parameter to determine where in the tree\n * the current execution is working\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport function walkResolverMap(object, inspector, wrap, path): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      const newPath = path.concat(key)\n      at(\n        product,\n        newPath,\n        walkResolverMap(value, inspector, wrap, newPath)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error(\n            `Invalid ResolverMap entry at ${path.join('.')}.${key}: value is ` +\n            `neither an object nor a function`\n          ))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method asyncWalkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {AsyncEntryInspector} [inspector=DefaultAsyncEntryInspector] the\n * inspector callback\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @param {string[]} path as `walkResolverMap` calls itself recursively,\n  * path is appended to and added as a parameter to determine where in the tree\n  * the current execution is working\n * @param {Error[]} skips if supplied, this array will have an appended\n * error for each sub async walk error caught.\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport async function asyncWalkResolverMap(\n  object,\n  inspector = DefaultAsyncEntryInspector,\n  wrap = true,\n  path = [],\n  skips\n) {\n  let product = {}\n\n  path.reduce((prev, cur) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      try {\n        at(\n          product,\n          path.concat(key),\n          await asyncWalkResolverMap(value, inspector, wrap, path, skips)\n        )\n      }\n      catch (stumble) {\n        if (skips && Array.isArray(skips)) {\n          skips.push(new ResolverMapStumble(stumble, {\n            key,\n            value,\n            source: object,\n            destination: product\n          }))\n        }\n      }\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = await inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Type definition for a property within a ResolverMap. It encapsulates the\n * property's name, value, the path to reach it within the object, and the\n * object itself.\n *\n * @typedef {{\n *   name: string,\n *   value: unknown,\n *   path: Array<string>,\n *   object: Object\n * }} ResolverProperty\n */\n\n/**\n * Merges two resolver objects recursively. In case of conflicting keys, the\n * provided `conflictResolver` function is called to determine the\n * resulting value.\n *\n * @param {Object} existingResolvers - The original set of resolvers.\n * @param {Object} newResolvers - The set of new resolvers to be merged into\n * the existing ones.\n * @param {Function} conflictResolver - A function that resolves conflicts\n * between existing and new resolver properties.\n * @returns {Object} The merged set of resolvers.\n */\nexport function mergeResolvers(existingResolvers, newResolvers, conflictResolver) {\n  // Recursive function to walk and merge the resolver maps\n  const walkAndMerge = (current, incoming, path = []) => {\n    for (const key of Object.keys(incoming)) {\n      const newPath = path.concat(key);\n\n      // Check if the key exists in the current object\n      if (Reflect.has(current, key)) {\n        const existingValue = current[key];\n        const incomingValue = incoming[key];\n\n        if (existingValue && typeof existingValue === 'object' && !Array.isArray(existingValue) && !isFn(existingValue)) {\n          // If both are objects, we need to go deeper\n          walkAndMerge(existingValue, incomingValue, newPath);\n        } else {\n          // Conflict detected, call the user-supplied conflict resolution function\n          const existingProp: ResolverProperty = {\n            name: key, value: existingValue, path, object: existingResolvers\n          }\n          const incomingProp: ResolverProperty = {\n            name: key, value: incomingValue, path, object: newResolvers\n          }\n          current[key] = conflictResolver(existingProp, incomingProp);\n        }\n      } else {\n        // No conflict, just set the value from the incoming object\n        current[key] = incoming[key];\n      }\n    }\n\n    return current\n  }\n\n  return walkAndMerge(existingResolvers, newResolvers, [])\n}\n\nexport default walkResolverMap\n"],"mappings":";;;;;;;;;;AAGA,IAAAA,OAAA,GAAAC,OAAA;AACA,IAAAC,SAAA,GAAAD,OAAA;AACA,IAAAE,OAAA,GAAAC,sBAAA,CAAAH,OAAA;AAAyB,SAAAG,uBAAAC,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAC,UAAA,GAAAD,CAAA,KAAAE,OAAA,EAAAF,CAAA;AALzB;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAMG,qBAAqB,GAAGA,CAACC,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEC,GAAG,KAAK;EAC9D,OAAO;IAAE,CAACH,GAAG,GAAGC;EAAM,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATAG,OAAA,CAAAL,qBAAA,GAAAA,qBAAA;AAUO,MAAMM,0BAA0B,GAAG,MAAAA,CAAOL,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEC,GAAG,KAAK;EACzE,OAAO;IAAE,CAACH,GAAG,GAAGC;EAAM,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApBAG,OAAA,CAAAC,0BAAA,GAAAA,0BAAA;AAqBO,SAASC,eAAeA,CAACC,MAAM,EAAEC,SAAS,EAAEC,IAAI,EAAEP,IAAI,EAAe;EAC1E,IAAIQ,OAAO,GAAG,CAAC,CAAC;EAEhBR,IAAI,CAACS,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,KAAK;IACzB,IAAI,CAAC,IAAAC,eAAE,EAACJ,OAAO,EAAEE,IAAI,CAACG,MAAM,CAACF,GAAG,CAAC,CAAC,EAAE;MAClC,IAAAC,eAAE,EAACJ,OAAO,EAAEE,IAAI,CAACG,MAAM,CAACF,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC;IACAD,IAAI,CAACI,IAAI,CAACH,GAAG,CAAC;IAEd,OAAOD,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;EAEN,KAAK,IAAI,CAACZ,GAAG,EAAEC,KAAK,CAAC,IAAIgB,MAAM,CAACC,OAAO,CAACX,MAAM,CAAC,EAAE;IAC/C,MAAMY,QAAiB,GAAGlB,KAAK,YAAYgB,MAAM;IACjD,MAAMG,UAAmB,GAAGD,QAAQ,IAAI,IAAAE,cAAI,EAACpB,KAAK,CAAC;IAEnD,IAAIkB,QAAQ,IAAI,CAACC,UAAU,EAAE;MAC3B,MAAME,OAAO,GAAGpB,IAAI,CAACa,MAAM,CAACf,GAAG,CAAC;MAChC,IAAAc,eAAE,EACAJ,OAAO,EACPY,OAAO,EACPhB,eAAe,CAACL,KAAK,EAAEO,SAAS,EAAEC,IAAI,EAAEa,OAAO,CACjD,CAAC;IACH,CAAC,MACI;MACH,IAAI,CAACH,QAAQ,IAAI,CAACC,UAAU,EAAE;QAC5B;QACA;QACA;QACA;QACA,IAAI,CAACX,IAAI,EAAE;UACT,MAAM,IAAIc,0BAAkB,CAAC,IAAIC,KAAK,CACpC,gCAAgCtB,IAAI,CAACuB,IAAI,CAAC,GAAG,CAAC,IAAIzB,GAAG,aAAa,GAClE,kCACF,CAAC,CAAC;QACJ,CAAC,MACI;UACHC,KAAK,GAAGA,CAAA,KAAMA,KAAK;QACrB;MACF;MAEA,IAAIyB,KAAK,GAAGlB,SAAS,CAACR,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEK,MAAM,CAAC;MAE/C,IAAImB,KAAK,KAAKC,SAAS,EAAE;QACvB,IAAAb,eAAE,EAACJ,OAAO,EAAER,IAAI,CAACa,MAAM,CAACf,GAAG,CAAC,EAAE0B,KAAK,CAAC1B,GAAG,CAAC,CAAC;MAC3C;IACF;EACF;EAEA,OAAOU,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAekB,oBAAoBA,CACxCrB,MAAM,EACNC,SAAS,GAAGH,0BAA0B,EACtCI,IAAI,GAAG,IAAI,EACXP,IAAI,GAAG,EAAE,EACT2B,KAAK,EACL;EACA,IAAInB,OAAO,GAAG,CAAC,CAAC;EAEhBR,IAAI,CAACS,MAAM,CAAC,CAACC,IAAI,EAAEC,GAAG,KAAK;IACzB,IAAI,CAAC,IAAAC,eAAE,EAACJ,OAAO,EAAEE,IAAI,CAACG,MAAM,CAACF,GAAG,CAAC,CAAC,EAAE;MAClC,IAAAC,eAAE,EAACJ,OAAO,EAAEE,IAAI,CAACG,MAAM,CAACF,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;IACnC;IACAD,IAAI,CAACI,IAAI,CAACH,GAAG,CAAC;IAEd,OAAOD,IAAI;EACb,CAAC,EAAE,EAAE,CAAC;EAEN,KAAK,IAAI,CAACZ,GAAG,EAAEC,KAAK,CAAC,IAAIgB,MAAM,CAACC,OAAO,CAACX,MAAM,CAAC,EAAE;IAC/C,MAAMY,QAAiB,GAAGlB,KAAK,YAAYgB,MAAM;IACjD,MAAMG,UAAmB,GAAGD,QAAQ,IAAI,IAAAE,cAAI,EAACpB,KAAK,CAAC;IAEnD,IAAIkB,QAAQ,IAAI,CAACC,UAAU,EAAE;MAC3B,IAAI;QACF,IAAAN,eAAE,EACAJ,OAAO,EACPR,IAAI,CAACa,MAAM,CAACf,GAAG,CAAC,EAChB,MAAM4B,oBAAoB,CAAC3B,KAAK,EAAEO,SAAS,EAAEC,IAAI,EAAEP,IAAI,EAAE2B,KAAK,CAChE,CAAC;MACH,CAAC,CACD,OAAOC,OAAO,EAAE;QACd,IAAID,KAAK,IAAIE,KAAK,CAACC,OAAO,CAACH,KAAK,CAAC,EAAE;UACjCA,KAAK,CAACb,IAAI,CAAC,IAAIO,0BAAkB,CAACO,OAAO,EAAE;YACzC9B,GAAG;YACHC,KAAK;YACLgC,MAAM,EAAE1B,MAAM;YACd2B,WAAW,EAAExB;UACf,CAAC,CAAC,CAAC;QACL;MACF;IACF,CAAC,MACI;MACH,IAAI,CAACS,QAAQ,IAAI,CAACC,UAAU,EAAE;QAC5B;QACA;QACA;QACA;QACA,IAAI,CAACX,IAAI,EAAE;UACT,MAAM,IAAIc,0BAAkB,CAAC,IAAIC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QAChE,CAAC,MACI;UACHvB,KAAK,GAAGA,CAAA,KAAMA,KAAK;QACrB;MACF;MAEA,IAAIyB,KAAK,GAAG,MAAMlB,SAAS,CAACR,GAAG,EAAEC,KAAK,EAAEC,IAAI,EAAEK,MAAM,CAAC;MAErD,IAAImB,KAAK,KAAKC,SAAS,EAAE;QACvB,IAAAb,eAAE,EAACJ,OAAO,EAAER,IAAI,CAACa,MAAM,CAACf,GAAG,CAAC,EAAE0B,KAAK,CAAC1B,GAAG,CAAC,CAAC;MAC3C;IACF;EACF;EAEA,OAAOU,OAAO;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASyB,cAAcA,CAACC,iBAAiB,EAAEC,YAAY,EAAEC,gBAAgB,EAAE;EAChF;EACA,MAAMC,YAAY,GAAGA,CAACC,OAAO,EAAEC,QAAQ,EAAEvC,IAAI,GAAG,EAAE,KAAK;IACrD,KAAK,MAAMF,GAAG,IAAIiB,MAAM,CAACyB,IAAI,CAACD,QAAQ,CAAC,EAAE;MACvC,MAAMnB,OAAO,GAAGpB,IAAI,CAACa,MAAM,CAACf,GAAG,CAAC;;MAEhC;MACA,IAAI2C,OAAO,CAACC,GAAG,CAACJ,OAAO,EAAExC,GAAG,CAAC,EAAE;QAC7B,MAAM6C,aAAa,GAAGL,OAAO,CAACxC,GAAG,CAAC;QAClC,MAAM8C,aAAa,GAAGL,QAAQ,CAACzC,GAAG,CAAC;QAEnC,IAAI6C,aAAa,IAAI,OAAOA,aAAa,KAAK,QAAQ,IAAI,CAACd,KAAK,CAACC,OAAO,CAACa,aAAa,CAAC,IAAI,CAAC,IAAAxB,cAAI,EAACwB,aAAa,CAAC,EAAE;UAC/G;UACAN,YAAY,CAACM,aAAa,EAAEC,aAAa,EAAExB,OAAO,CAAC;QACrD,CAAC,MAAM;UACL;UACA,MAAMyB,YAA8B,GAAG;YACrCC,IAAI,EAAEhD,GAAG;YAAEC,KAAK,EAAE4C,aAAa;YAAE3C,IAAI;YAAEK,MAAM,EAAE6B;UACjD,CAAC;UACD,MAAMa,YAA8B,GAAG;YACrCD,IAAI,EAAEhD,GAAG;YAAEC,KAAK,EAAE6C,aAAa;YAAE5C,IAAI;YAAEK,MAAM,EAAE8B;UACjD,CAAC;UACDG,OAAO,CAACxC,GAAG,CAAC,GAAGsC,gBAAgB,CAACS,YAAY,EAAEE,YAAY,CAAC;QAC7D;MACF,CAAC,MAAM;QACL;QACAT,OAAO,CAACxC,GAAG,CAAC,GAAGyC,QAAQ,CAACzC,GAAG,CAAC;MAC9B;IACF;IAEA,OAAOwC,OAAO;EAChB,CAAC;EAED,OAAOD,YAAY,CAACH,iBAAiB,EAAEC,YAAY,EAAE,EAAE,CAAC;AAC1D;AAAC,IAAAa,QAAA,GAAA9C,OAAA,CAAAN,OAAA,GAEcQ,eAAe","ignoreList":[]}