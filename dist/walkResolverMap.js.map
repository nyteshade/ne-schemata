{"version":3,"file":"walkResolverMap.js","names":["_errors","require","_typework","_propAt","_interopRequireDefault","e","__esModule","default","DefaultEntryInspector","key","value","path","map","exports","DefaultAsyncEntryInspector","walkResolverMap","object","inspector","wrap","product","reduce","prev","cur","at","concat","push","Object","entries","isObject","isFunction","isFn","newPath","ResolverMapStumble","Error","join","entry","undefined","asyncWalkResolverMap","skips","stumble","Array","isArray","source","destination","mergeResolvers","existingResolvers","newResolvers","conflictResolver","c","walkAndMerge","current","incoming","keys","Reflect","has","existingValue","incomingValue","existingProp","name","incomingProp","_default"],"sources":["../src/walkResolverMap.js"],"sourcesContent":["// @ts-check\n\nimport type { ResolverMap, EntryInspector, AsyncEntryInspector } from './types'\nimport { ResolverMapStumble } from './errors'\nimport { isFn, getType } from './utils/typework'\nimport at from './propAt'\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `walkResolverMap`. While not immediately useful, a default implementation\n * causes `walkResolverMap` to wrap any non-function and non-object values\n * with a function that returns the non-compliant value and therefore has some\n * intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultEntryInspector: EntryInspector = (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `asyncWalkResolverMap`. While not immediately useful, a default\n * implementation causes `asyncWalkResolverMap` to wrap any non-function and\n * non-object values with a function that returns the non-compliant value and\n * therefore has some intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultAsyncEntryInspector: AsyncEntryInspector = async (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method walkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @param {Array<string>} path as `walkResolverMap` calls itself recursively,\n * path is appended to and added as a parameter to determine where in the tree\n * the current execution is working\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport function walkResolverMap(\n  object: ResolverMap,\n  inspector: EntryInspector = DefaultEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      const newPath = path.concat(key)\n      at(\n        product,\n        newPath,\n        walkResolverMap(value, inspector, wrap, newPath)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error(\n            `Invalid ResolverMap entry at ${path.join('.')}.${key}: value is ` +\n            `neither an object nor a function`\n          ))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method asyncWalkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @param {Array<string>} path as `walkResolverMap` calls itself recursively,\n  * path is appended to and added as a parameter to determine where in the tree\n  * the current execution is working\n * @param {Array<error>} skips if supplied, this array will have an appended\n * error for each sub async walk error caught.\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport async function asyncWalkResolverMap(\n  object: ResolverMap,\n  inspector: AsyncEntryInspector = DefaultAsyncEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = [],\n  skips: Array<error>\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      try {\n        at(\n          product,\n          path.concat(key),\n          await asyncWalkResolverMap(value, inspector, wrap, path, skips)\n        )\n      }\n      catch (stumble) {\n        if (skips && Array.isArray(skips)) {\n          skips.push(new ResolverMapStumble(stumble, {\n            key,\n            value,\n            source: object,\n            destination: product\n          }))\n        }\n      }\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = await inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Type definition for a property within a ResolverMap. It encapsulates the\n * property's name, value, the path to reach it within the object, and the\n * object itself.\n *\n * @flow\n * @type {ResolverProperty}\n */\nexport type ResolverProperty = {\n  name: string,\n  value: unknown,\n  path: Array<string>,\n  object: Object\n}\n\n/**\n * Merges two resolver objects recursively. In case of conflicting keys, the\n * provided `conflictResolver` function is called to determine the\n * resulting value.\n *\n * @flow\n * @param {Object} existingResolvers - The original set of resolvers.\n * @param {Object} newResolvers - The set of new resolvers to be merged into\n * the existing ones.\n * @param {function} conflictResolver - A function that resolves conflicts\n * between existing and new resolver properties.\n * @returns {Object} The merged set of resolvers.\n */\nexport function mergeResolvers(\n  existingResolvers: Object,\n  newResolvers: Object,\n  conflictResolver: (\n    existing: ResolverProperty,\n    conflict: ResolverProperty\n  ) => mixed = (e,c) => c.value\n) {\n  // Recursive function to walk and merge the resolver maps\n  const walkAndMerge = (current, incoming, path = []) => {\n    for (const key of Object.keys(incoming)) {\n      const newPath = path.concat(key);\n\n      // Check if the key exists in the current object\n      if (Reflect.has(current, key)) {\n        const existingValue = current[key];\n        const incomingValue = incoming[key];\n\n        if (existingValue && typeof existingValue === 'object' && !Array.isArray(existingValue) && !isFn(existingValue)) {\n          // If both are objects, we need to go deeper\n          walkAndMerge(existingValue, incomingValue, newPath);\n        } else {\n          // Conflict detected, call the user-supplied conflict resolution function\n          const existingProp: ResolverProperty = {\n            name: key, value: existingValue, path, object: existingResolvers\n          }\n          const incomingProp: ResolverProperty = {\n            name: key, value: incomingValue, path, object: newResolvers\n          }\n          current[key] = conflictResolver(existingProp, incomingProp);\n        }\n      } else {\n        // No conflict, just set the value from the incoming object\n        current[key] = incoming[key];\n      }\n    }\n\n    return current\n  }\n\n  return walkAndMerge(existingResolvers, newResolvers, [])\n}\n\nexport default walkResolverMap\n"],"mappings":"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","ignoreList":[]}