{"version":3,"sources":["../src/walkResolverMap.js"],"names":["walkResolverMap","asyncWalkResolverMap","isFn","o","test","Object","prototype","toString","call","DefaultEntryInspector","key","value","path","map","DefaultAsyncEntryInspector","object","inspector","wrap","product","reduce","prev","cur","index","concat","push","entries","isObject","isFunction","ResolverMapStumble","Error","entry","undefined"],"mappings":"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","file":"walkResolverMap.js","sourceRoot":"src","sourcesContent":["// @flow\n\nimport type { ResolverMap, EntryInspector, AsyncEntryInspector } from './types'\nimport { ResolverMapStumble } from './errors'\nimport at from './propAt'\nimport merge from 'deepmerge'\n\nconst isFn = o => /Function\\]/.test(Object.prototype.toString.call(o))\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `walkResolverMap`. While not immediately useful, a default implementation\n * causes `walkResolverMap` to wrap any non-function and non-object values\n * with a function that returns the non-compliant value and therefore has some\n * intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultEntryInspector: EntryInspector = (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * A default implementation of the EntryInspector type for use as a default\n * to `asyncWalkResolverMap`. While not immediately useful, a default\n * implementation causes `asyncWalkResolverMap` to wrap any non-function and\n * non-object values with a function that returns the non-compliant value and\n * therefore has some intrinsic value.\n *\n * @method DefaultEntryInspector\n * @type {Function}\n */\nexport const DefaultAsyncEntryInspector: AsyncEntryInspector = async (\n  key,\n  value,\n  path,\n  map\n) => {\n  return { [key]: value }\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method walkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport function walkResolverMap(\n  object: ResolverMap,\n  inspector: EntryInspector = DefaultEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur, index) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      at(\n        product,\n        path.concat(key),\n        walkResolverMap(value, inspector, wrap, path)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\n/**\n * Given a `ResolverMap` object, walk its properties and allow execution\n * with each key, value pair. If the supplied function for handling a given\n * entry returns null instead of an object with the format `{key: value}`\n * then that entry will not be included in the final output.\n *\n * @method asyncWalkResolverMap\n *\n * @param {ResolverMap} object an object conforming to type `ResolverMap`\n * @param {boolean} wrap defaults to true. An entry whose value is neither a\n * function nor an object will be wrapped in a function returning the value. If\n * false is supplied here, a `ResolverMapStumble` error will be thrown instead\n * @return {ResolverMap} upon successful completion, a `ResolverMap` object,\n * modified as specified, will be returned instead.\n */\nexport async function asyncWalkResolverMap(\n  object: ResolverMap,\n  inspector: AsyncEntryInspector = DefaultAsyncEntryInspector,\n  wrap: boolean = true,\n  path: Array<string> = []\n): ResolverMap {\n  let product = {}\n\n  path.reduce((prev, cur, index) => {\n    if (!at(product, prev.concat(cur))) {\n      at(product, prev.concat(cur), {})\n    }\n    prev.push(cur)\n\n    return prev\n  }, [])\n\n  for (let [key, value] of Object.entries(object)) {\n    const isObject: boolean = value instanceof Object\n    const isFunction: boolean = isObject && isFn(value)\n\n    if (isObject && !isFunction) {\n      at(\n        product,\n        path.concat(key),\n        await asyncWalkResolverMap(value, inspector, wrap, path)\n      )\n    }\n    else {\n      if (!isObject && !isFunction) {\n        // In the case that we have a string mapping to a non-function and a\n        // non-object, we can do one of two things. Either we can throw an error\n        // or by default we simply wrap the value in a function that returns\n        // that value\n        if (!wrap) {\n          throw new ResolverMapStumble(new Error('Invalid ResolverMap'))\n        }\n        else {\n          value = () => value\n        }\n      }\n\n      let entry = await inspector(key, value, path, object)\n\n      if (entry !== undefined) {\n        at(product, path.concat(key), entry[key])\n      }\n    }\n  }\n\n  return product\n}\n\nexport default walkResolverMap\n"]}